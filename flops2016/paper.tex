\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% This is the default style configuration for Scribble-generated Latex
 
\usepackage{graphicx}
\usepackage{hyperref}
\renewcommand{\rmdefault}{ptm}
\usepackage{relsize}
\usepackage{mathabx}
% Avoid conflicts between "mathabx" and "wasysym":
\let\leftmoon\relax \let\rightmoon\relax \let\fullmoon\relax \let\newmoon\relax \let\diameter\relax
\usepackage{wasysym}
\usepackage{textcomp}
\usepackage{framed}
\usepackage[htt]{hyphenat}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{bookmarks=true,bookmarksopen=true,bookmarksnumbered=true}
\IfFileExists{tocstyle.sty}{\usepackage{tocstyle}\usetocstyle{standard}}{}
\IfFileExists{CJK.sty}{\usepackage{CJK}}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configuration that is especially meant to be overridden:

% Inserted before every ``chapter'', useful for starting each one on a new page:
\newcommand{\sectionNewpage}{}
% Inserted before every book ``part''
\newcommand{\partNewpage}{\sectionNewpage}

% Hooks for actions within the `document' environment:
\newcommand{\preDoc}{}
\newcommand{\postDoc}{}

% Generated by `secref'; first arg is section number, second is section title:
\newcommand{\BookRef}[2]{\emph{#2}}
\newcommand{\ChapRef}[2]{\SecRef{#1}{#2}}
\newcommand{\SecRef}[2]{section~#1}
\newcommand{\PartRef}[2]{part~#1}
% Generated by `Secref':
\newcommand{\BookRefUC}[2]{\BookRef{#1}{#2}}
\newcommand{\ChapRefUC}[2]{\SecRefUC{#1}{#2}}
\newcommand{\SecRefUC}[2]{Section~#1}
\newcommand{\PartRefUC}[2]{Part~#1}

% Variants of the above with a label for an internal reference:
\newcommand{\BookRefLocal}[3]{\hyperref[#1]{\BookRef{#2}{#3}}}
\newcommand{\ChapRefLocal}[3]{\hyperref[#1]{\ChapRef{#2}{#3}}}
\newcommand{\SecRefLocal}[3]{\hyperref[#1]{\SecRef{#2}{#3}}}
\newcommand{\PartRefLocal}[3]{\hyperref[#1]{\PartRef{#2}{#3}}}
\newcommand{\BookRefLocalUC}[3]{\hyperref[#1]{\BookRefUC{#2}{#3}}}
\newcommand{\ChapRefLocalUC}[3]{\hyperref[#1]{\ChapRefUC{#2}{#3}}}
\newcommand{\SecRefLocalUC}[3]{\hyperref[#1]{\SecRefUC{#2}{#3}}}
\newcommand{\PartRefLocalUC}[3]{\hyperref[#1]{\PartRefUC{#2}{#3}}}

% Variants of the above with a section number is empty (i.e., UnNumbered):
\newcommand{\BookRefUN}[1]{\BookRef{}{#1}}
\newcommand{\ChapRefUN}[1]{\SecRefUN{#1}}
\newcommand{\SecRefUN}[1]{``#1''}
\newcommand{\PartRefUN}[1]{\SecRefUN{#1}}
\newcommand{\BookRefUCUN}[1]{\BookRefUN{#1}}
\newcommand{\ChapRefUCUN}[1]{\ChapRefUN{#1}}
\newcommand{\SecRefUCUN}[1]{\SecRefUN{#1}}
\newcommand{\PartRefUCUN}[1]{\PartRefUN{#1}}

\newcommand{\BookRefLocalUN}[2]{\hyperref[#1]{\BookRefUN{#2}}}
\newcommand{\ChapRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUN}[2]{\SecRefUN{#2} on page~\pageref{#1}}
\newcommand{\PartRefLocalUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\BookRefLocalUCUN}[2]{\BookRefLocalUN{#1}{#2}}
\newcommand{\ChapRefLocalUCUN}[2]{\ChapRefLocalUN{#1}{#2}}
\newcommand{\SecRefLocalUCUN}[2]{\SecRefLocalUN{#1}{#2}}
\newcommand{\PartRefLocalUCUN}[2]{\PartRefLocalUN{#1}{#2}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonts

% Font commands used by generated text:
\newcommand{\Scribtexttt}[1]{{\texttt{#1}}}
\newcommand{\textsub}[1]{$_{\hbox{\textsmaller{#1}}}$}
\newcommand{\textsuper}[1]{$^{\hbox{\textsmaller{#1}}}$}
\newcommand{\intextcolor}[2]{\textcolor{#1}{#2}}
\newcommand{\intextrgbcolor}[2]{\textcolor[rgb]{#1}{#2}}
\newcommand{\incolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\colorbox{#1}{#2}}}
\newcommand{\inrgbcolorbox}[2]{{\fboxrule=0pt\fboxsep=0pt\colorbox[rgb]{#1}{#2}}}
\newcommand{\plainlink}[1]{#1}
\newcommand{\techoutside}[1]{#1}
\newcommand{\techinside}[1]{#1}
\newcommand{\badlink}[1]{#1}
\newcommand{\indexlink}[1]{#1}
\newcommand{\noborder}[1]{#1}
\newcommand{\Smaller}[1]{\textsmaller{#1}}
\newcommand{\Larger}[1]{\textlarger{#1}}
\newcommand{\planetName}[1]{PLane\hspace{-0.1ex}T}
\newcommand{\slant}[1]{{\textsl{#1}}}

% Used for <, >, and | in tt mode. For some fonts and installations,
% there seems to be an encoding issue, so pick T1 explicitly:
\newcommand{\Stttextmore}{{\fontencoding{T1}\selectfont>}}
\newcommand{\Stttextless}{{\fontencoding{T1}\selectfont<}}
\newcommand{\Stttextbar}{{\fontencoding{T1}\selectfont|}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tables

% The `stabular' environment seems to be the lesser of evils among 
%  page-breaking table environments (and we've made a copy as ``pltstabular'
%  to make sure that it doesn't change).

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\message{pltstabular is a modification of stabular}
%% A renamed vsetion of:
%% stabular.sty
%% Copyright 1998 Sigitas Tolu\v sis
%% VTeX Ltd., Akademijos 4, Vilnius, Lithuania
%% e-mail sigitas@vtex.lt
%% http://www.vtex.lt/tex/download/macros/
%%
% This program can redistributed and/or modified under the terms
% of the LaTeX Project Public License Distributed from CTAN
% archives in directory macros/latex/base/lppl.txt; either
% version 1 of the License, or (at your option) any later version.
%
% PURPOSE:   Improve tabular environment.
%
% SHORT DESCRIPTION:
%
% Changed internal commands: \@mkpream, \@addamp, \@xhline
%
% Provides new commands in tabular (used after command \\):
% \emptyrow[#1] 
% -------------
%    Adds empty row, #1 - height of the row 
%
% \tabrow{#1}[#2] 
% ---------------
%    Adds row of natural height: #1\\[#2]
%
% Provides new environments: pltstabular and pltstabular* 
%                            --------     ---------
%            One more multi-page version of tabular
%
%
\def\empty@finalstrut#1{%
  \unskip\ifhmode\nobreak\fi\vrule\@width\z@\@height\z@\@depth\z@}
\def\no@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\z@
           \@depth\z@
           \@width\z@}%
    \gdef\@endpbox{\empty@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\yes@strut{\global\setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch \ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
    \gdef\@endpbox{\@finalstrut\@arstrutbox\par\egroup\hfil}%
}%
\def\@mkpream#1{\@firstamptrue\@lastchclass6
  \let\@preamble\@empty\def\empty@preamble{\add@ins}%
  \let\protect\@unexpandable@protect
  \let\@sharp\relax\let\add@ins\relax
  \let\@startpbox\relax\let\@endpbox\relax
  \@expast{#1}%
  \expandafter\@tfor \expandafter
    \@nextchar \expandafter:\expandafter=\reserved@a\do
       {\@testpach\@nextchar
    \ifcase \@chclass \@classz \or \@classi \or \@classii \or \@classiii
      \or \@classiv \or\@classv \fi\@lastchclass\@chclass}%
  \ifcase \@lastchclass \@acol
      \or \or \@preamerr \@ne\or \@preamerr \tw@\or \or \@acol \fi}
\def\@addamp{%
  \if@firstamp
    \@firstampfalse
    \edef\empty@preamble{\add@ins}%
  \else
    \edef\@preamble{\@preamble &}%
    \edef\empty@preamble{\expandafter\noexpand\empty@preamble &\add@ins}%
  \fi}
\newif\iftw@hlines \tw@hlinesfalse
\def\@xhline{\ifx\reserved@a\hline
               \tw@hlinestrue
             \else\ifx\reserved@a\Hline
               \tw@hlinestrue
             \else
               \tw@hlinesfalse
             \fi\fi
      \iftw@hlines
        \aftergroup\do@after
      \fi
      \ifnum0=`{\fi}%
}
\def\do@after{\emptyrow[\the\doublerulesep]}
\def\emptyrow{\noalign\bgroup\@ifnextchar[\@emptyrow{\@emptyrow[\z@]}}
\def\@emptyrow[#1]{\no@strut\gdef\add@ins{\vrule \@height\z@ \@depth#1 \@width\z@}\egroup%
\empty@preamble\\
\noalign{\yes@strut\gdef\add@ins{\vrule \@height\z@ \@depth\z@ \@width\z@}}%
}
\def\tabrow#1{\noalign\bgroup\@ifnextchar[{\@tabrow{#1}}{\@tabrow{#1}[]}}
\def\@tabrow#1[#2]{\no@strut\egroup#1\ifx.#2.\\\else\\[#2]\fi\noalign{\yes@strut}}
%
\def\endpltstabular{\crcr\egroup\egroup \egroup}
\expandafter \let \csname endpltstabular*\endcsname = \endpltstabular
\def\pltstabular{\let\@halignto\@empty\@pltstabular}
\@namedef{pltstabular*}#1{\def\@halignto{to#1}\@pltstabular}
\def\@pltstabular{\leavevmode \bgroup \let\@acol\@tabacol
   \let\@classz\@tabclassz
   \let\@classiv\@tabclassiv \let\\\@tabularcr\@stabarray}
\def\@stabarray{\m@th\@ifnextchar[\@sarray{\@sarray[c]}}
\def\@sarray[#1]#2{%
  \bgroup
  \setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch\ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
  \@mkpream{#2}%
  \edef\@preamble{%
    \ialign \noexpand\@halignto
      \bgroup \@arstrut \@preamble \tabskip\z@skip \cr}%
  \let\@startpbox\@@startpbox \let\@endpbox\@@endpbox
  \let\tabularnewline\\%
%    \let\par\@empty
    \let\@sharp##%
    \set@typeset@protect
    \lineskip\z@skip\baselineskip\z@skip
    \@preamble}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatother

\newenvironment{bigtabular}{\begin{pltstabular}}{\end{pltstabular}}
% For the 'boxed table style:
\newcommand{\SBoxedLeft}{\textcolor[rgb]{0.6,0.6,1.0}{\vrule width 3pt\hspace{3pt}}}
% Formerly used to keep the horizontal line for a definition on the same page:
\newcommand{\SEndFirstHead}[0]{ \nopagebreak \\ }
% Corrects weirdness when a table is the first thing in
%  an itemization:
\newcommand{\bigtableinlinecorrect}[0]{~

\vspace{-\baselineskip}\vspace{\parskip}}
% Used to indent the table correctly in an itemization, since that's
%  one of the things stabular gets wrong:
\newlength{\stabLeft}
\newcommand{\bigtableleftpad}{\hspace{\stabLeft}}
\newcommand{\atItemizeStart}[0]{\addtolength{\stabLeft}{\labelsep}
                                \addtolength{\stabLeft}{\labelwidth}}


% For a single-column table in simple environments, it's better to
%  use the `list' environment instead of `stabular'.
\newenvironment{SingleColumn}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Etc.

% ._ and .__
\newcommand{\Sendabbrev}[1]{#1\@}
\newcommand{\Sendsentence}[1]{\@#1}

% Default style for a nested flow:
\newenvironment{Subflow}{\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt}\item}{\end{list}}

% For the 'inset nested-flow style:
\newenvironment{SInsetFlow}{\begin{quote}}{\end{quote}}

% Indent a 'code-inset nested flow:
\newcommand{\SCodePreSkip}{\vskip\abovedisplayskip}
\newcommand{\SCodePostSkip}{\vskip\belowdisplayskip}
\newenvironment{SCodeFlow}{\SCodePreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=2ex\rightmargin=2ex%
\itemsep=0pt\parsep=0pt}\item}{\end{list}\SCodePostSkip}
\newcommand{\SCodeInsetBox}[1]{\setbox1=\hbox{\hbox{\hspace{2ex}#1\hspace{2ex}}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% Inset a 'vertical-inset nested flow:
\newcommand{\SVInsetPreSkip}{\vskip\abovedisplayskip}
\newcommand{\SVInsetPostSkip}{\vskip\belowdisplayskip}
\newenvironment{SVInsetFlow}{\SVInsetPreSkip\begin{list}{}{\topsep=0pt\partopsep=0pt%
\listparindent=0pt\itemindent=0pt\labelwidth=0pt\leftmargin=0pt\rightmargin=0pt%
\itemsep=0pt\parsep=0pt}\item}{\end{list}\SVInsetPostSkip}
\newcommand{\SVInsetBox}[1]{\setbox1=\hbox{\hbox{#1}}\vbox{\SCodePreSkip\vtop{\box1\SCodePostSkip}}}

% The 'compact itemization style:
\newenvironment{compact}{\begin{itemize}}{\end{itemize}}
\newcommand{\compactItem}[1]{\item #1}

% The nested-flow style for `centerline':
\newenvironment{SCentered}{\begin{trivlist}\item \centering}{\end{trivlist}}

% The \refpara command corresponds to `margin-note'. The
% refcolumn and refcontent environments also wrap the note,
% because they simplify the CSS side.
\newcommand{\refpara}[1]{\normalmarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelem}[1]{\refpara{#1}}
\newenvironment{refcolumn}{}{}
\newenvironment{refcontent}{}{}

\newcommand{\refparaleft}[1]{\reversemarginpar\marginpar{\raggedright \footnotesize #1}}
\newcommand{\refelemleft}[1]{\refparaleft{#1}}
\newenvironment{refcolumnleft}{}{}

% Macros used by `title' and `author':
\newcommand{\titleAndVersionAndAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}\author{#3}\maketitle}
\newcommand{\titleAndVersionAndEmptyAuthors}[3]{\title{#1\\{\normalsize \SVersionBefore{}#2}}#3\maketitle}
\newcommand{\titleAndEmptyVersionAndAuthors}[3]{\title{#1}\author{#3}\maketitle}
\newcommand{\titleAndEmptyVersionAndEmptyAuthors}[3]{\title{#1}\maketitle}
\newcommand{\SAuthor}[1]{#1}
\newcommand{\SAuthorSep}[1]{\qquad}
\newcommand{\SVersionBefore}[1]{Version }

% Useful for some styles, such as sigalternate:
\newcommand{\SNumberOfAuthors}[1]{}

\let\SOriginalthesubsection\thesubsection
\let\SOriginalthesubsubsection\thesubsubsection

% sections
\newcommand{\Spart}[2]{\part[#1]{#2}}
\newcommand{\Ssection}[2]{\section[#1]{#2}\let\thesubsection\SOriginalthesubsection}
\newcommand{\Ssubsection}[2]{\subsection[#1]{#2}\let\thesubsubsection\SOriginalthesubsubsection}
\newcommand{\Ssubsubsection}[2]{\subsubsection[#1]{#2}}
\newcommand{\Ssubsubsubsection}[2]{{\bf #2}}
\newcommand{\Ssubsubsubsubsection}[2]{\Ssubsubsubsection{#1}{#2}}

% "star" means unnumbered and not in ToC:
\newcommand{\Spartstar}[1]{\part*{#1}}
\newcommand{\Ssectionstar}[1]{\section*{#1}\renewcommand*\thesubsection{\arabic{subsection}}\setcounter{subsection}{0}}
\newcommand{\Ssubsectionstar}[1]{\subsection*{#1}\renewcommand*\thesubsubsection{\arabic{section}.\arabic{subsubsection}}\setcounter{subsubsection}{0}}
\newcommand{\Ssubsubsectionstar}[1]{\subsubsection*{#1}}
\newcommand{\Ssubsubsubsectionstar}[1]{{\bf #1}}
\newcommand{\Ssubsubsubsubsectionstar}[1]{\Ssubsubsubsectionstar{#1}}

% "starx" means unnumbered but in ToC:
\newcommand{\Spartstarx}[2]{\Spartstar{#2}\addcontentsline{toc}{part}{#1}}
\newcommand{\Ssectionstarx}[2]{\Ssectionstar{#2}\addcontentsline{toc}{section}{#1}}
\newcommand{\Ssubsectionstarx}[2]{\Ssubsectionstar{#2}\addcontentsline{toc}{subsection}{#1}}
\newcommand{\Ssubsubsectionstarx}[2]{\Ssubsubsectionstar{#2}\addcontentsline{toc}{subsubsection}{#1}}
\newcommand{\Ssubsubsubsectionstarx}[2]{\Ssubsubsubsectionstar{#2}}
\newcommand{\Ssubsubsubsubsectionstarx}[2]{\Ssubsubsubsubsectionstar{#2}}

% "grouper" is for the 'grouper style variant --- on subsections and lower,
%  because \Spart is used for grouper at the section level. Grouper implies
%  unnumbered.
\newcounter{GrouperTemp}
\newcommand{\Ssubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouper}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouper}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouper}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

\newcommand{\Ssubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstar{#1}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstar}[1]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstar{#1}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstar}[1]{\Ssubsubsubsectionstar{#1}}
\newcommand{\Ssubsubsubsubsectiongrouperstar}[1]{\Ssubsubsubsubsectionstar{#1}}

\newcommand{\Ssubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsection}}\Ssubsectionstarx{#1}{#2}\setcounter{subsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsectiongrouperstarx}[2]{\setcounter{GrouperTemp}{\value{subsubsection}}\Ssubsubsectionstarx{#1}{#2}\setcounter{subsubsection}{\value{GrouperTemp}}}
\newcommand{\Ssubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsectionstarx{#1}{#2}}
\newcommand{\Ssubsubsubsubsectiongrouperstarx}[2]{\Ssubsubsubsubsectionstarx{#1}{#2}}

% Generated by `subsubsub*section':
\newcommand{\SSubSubSubSection}[1]{\Ssubsubsubsubsectionstar{#1}}

% For hidden parts with an empty title:
\newcommand{\notitlesection}{\vspace{2ex}\phantomsection\noindent}

% To increments section numbers:
\newcommand{\Sincpart}{\stepcounter{part}}
\newcommand{\Sincsection}{\stepcounter{section}}
\newcommand{\Sincsubsection}{\stepcounter{subsection}}
\newcommand{\Sincsubsubsection}{\stepcounter{subsubsection}}
\newcommand{\Sincsubsubsubsection}{}
\newcommand{\Sincsubsubsubsubsection}{}

% When brackets appear in section titles:
\newcommand{\SOpenSq}{[}
\newcommand{\SCloseSq}{]}

% Helper for box-mode macros:
\newcommand{\Svcenter}[1]{$\vcenter{#1}$}

% Helper to work around a problem with "#"s for URLs within \href
% within other macros:
\newcommand{\Shref}[3]{\href{#1\##2}{#3}}

% For URLs:
\newcommand{\Snolinkurl}[1]{\nolinkurl{#1}}

% History note:
\newcommand{\SHistory}[1]{\begin{smaller}#1\end{smaller}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Scribble then generates the following:
%
%  \begin{document}
%  \preDoc
%  \titleAndVersion{...}{...}
%  ... document content ...
%  \postDoc
%  \end{document}
\usepackage{pslatex}
\usepackage{inconsolata}
\newenvironment{InlineCode}{\begin{trivlist}\item\footnotesize}{\end{trivlist}}
\newcommand{\LNCSand}{\and}

\newcommand{\LNCSauthor}[1]{\author{#1}}
\newcommand{\LNCSinst}[1]{\inst{#1}}

\newcommand{\LNCSinstitutes}[1]{\institute{#1}}
\newcommand{\LNCSinstitute}[1]{#1}

\newcommand{\LNCSemail}[1]{\email{#1}}

\renewcommand{\SAuthorSep}{}
\usepackage{ccaption}

% \legend relies on \belowcaptionskip, which is not defined
% by the JFP class file:
\makeatletter
\@ifundefined{belowcaptionskip}{\newlength{\belowcaptionskip}}{}
\makeatother

\newcommand{\Legend}[1]{~

                        \hrule width \hsize height .33pt
                        \vspace{4pt}
                        \legend{#1}}

\newcommand{\LegendContinued}[1]{\Legend{#1}}

\newcommand{\FigureTarget}[2]{#1}
\newcommand{\FigureRef}[2]{\hyperref[#2]{#1}}

\newlength{\FigOrigskip}
\FigOrigskip=\parskip

% Put this before the figure content, so that a hyperref goes to
% the start of the content:
\newcommand{\FigureSetRef}{\refstepcounter{figure}}

\newenvironment{Figure}{\begin{figure}\FigureSetRef}{\end{figure}}
\newenvironment{FigureMulti}{\begin{figure*}[t!p]\FigureSetRef}{\end{figure*}}
\newenvironment{FigureMultiWide}{\begin{FigureMulti}\FigureSetRef}{\end{FigureMulti}}
\newenvironment{Herefigure}{\begin{figure}[ht!]\FigureSetRef\centering}{\end{figure}}

\newenvironment{Centerfigure}{\begin{Xfigure}\centering\item}{\end{Xfigure}}
\newenvironment{Leftfigure}{\begin{Xfigure}\item}{\end{Xfigure}}
\newenvironment{Rightfigure}{\begin{Xfigure}\item}{\end{Xfigure}}

\newenvironment{Xfigure}{\begin{list}{}{\leftmargin=0pt\topsep=0pt\parsep=\FigOrigskip\partopsep=0pt}}{\end{list}}

\newenvironment{FigureInside}{}{}

\newcommand{\Centertext}[1]{\begin{center}#1\end{center}}



\newcommand{\NoteBox}[1]{\footnote{#1}}
\newcommand{\NoteContent}[1]{#1}

\newcommand{\Footnote}[1]{\footnote{#1}}
\newcommand{\FootnoteRef}[1]{}
\newcommand{\FootnoteTarget}[1]{}
\newcommand{\FootnoteContent}[1]{#1}

% Redefine \noindent to avoid generating any output at all:
\newenvironment{FootnoteBlock}{\renewcommand{\noindent}{}}{}
\newcommand{\FootnoteBlockContent}[1]{}

\newenvironment{AutoBibliography}{\begin{small}}{\end{small}}
\newcommand{\Autobibentry}[1]{\hspace{0.05\linewidth}\parbox[t]{0.95\linewidth}{\parindent=-0.05\linewidth#1\vspace{1.0ex}}}

\usepackage{calc}
\newlength{\ABcollength}
\newcommand{\Autocolbibnumber}[1]{\parbox[t]{5ex}{\hfill#1~~\vspace{1.0ex}}}
\newcommand{\Autocolbibentry}[1]{\setlength{\ABcollength}{\linewidth-5ex}\parbox[t]{\ABcollength}{#1\vspace{1.0ex}}}

\renewcommand{\titleAndVersionAndAuthors}[3]{\title{#1}\titlerunning{#2}#3\maketitle}
\renewcommand{\titleAndEmptyVersionAndAuthors}[3]{\titleAndVersionAndAuthors{#1}{#1}{#3}}
\begin{document}
\preDoc
\titleAndEmptyVersionAndAuthors{A Coq Library For Internal Verification of Running{-}Times}{}{\SNumberOfAuthors{2}\SAuthor{\LNCSauthor{Jay McCarthy\LNCSinst{1}\LNCSand{}Burke Fetscher\LNCSinst{2}\LNCSand{}Max New\LNCSinst{2}\LNCSand{}\hspace*{\fill}\\ Daniel Feltey\LNCSinst{2}\LNCSand{}Robert Bruce Findler\LNCSinst{2}}}\SAuthorSep{}\SAuthor{\LNCSinstitutes{University of Massachusetts at Lowell\hspace*{\fill}\\\LNCSemail{jay.mccarthy@gmail.com}\LNCSand{}Northwestern University\hspace*{\fill}\\\LNCSemail{\{burke.fetscher, max.new, daniel.feltey, robby\}@eecs.northwestern.edu}}}}
\label{t:x28part_x22Ax5fCoqx5fLibraryx5fForx5fInternalx5fVerificationx5fofx5fRunningx2dTimesx22x29}





\begin{abstract}This paper presents a Coq library that lifts an abstract yet precise
notion of running{-}time into the type of a function. Our library is
based on a monad that counts abstract steps, controlled by one of the
monadic operations. The monad{'}s computational content, however, is
simply that of the identity monad so programs written in our
monad (that recur on the natural structure of their arguments) extract
into idiomatic OCaml code. We evaluated the expressiveness of the
library by proving that red{-}black tree insertion and search, merge
sort, insertion sort, Fibonacci, iterated list insertion, BigNum
addition, and Okasaki{'}s Braun Tree algorithms all have their expected
running times.\end{abstract}

\sectionNewpage

\Ssection{Introduction}{Introduction}\label{t:x28part_x22Introductionx22x29}

For some programs, proving that they have correct input{-}output
behavior is only part of the story. As Crosby and Wallach~(2003)
observed, incorrect performance characteristics can also lead
to security vulnerabilities. Indeed, some programs and algorithms
are valuable precisely because of their performance
characteristics. For example, mergesort is preferable to insertion
sort only because of its improved running time.
Unfortunately, defining functions in Coq or other theorem
proving systems does not provide enough information in the types to be
able to state these intensional properties.

Our work provides a monad (implemented as a library in Coq) that
enables us to include abstract running times in types. We use this
library to prove several important algorithms have their expected
running times.  Our library has two benefits over
Danielsson~(2008){'}s.
First, it allows programmers
to write idiomatic code without embedding invariants in data types,
so we can reason about a wider variety of programs. Second, and more
significantly, our monad adds no complexity
computations to the extracted OCaml code, so it has no verification
overhead on running time.  We elaborate these details and differences
throughout the paper and, in particular, in
\ChapRefLocal{t:x28part_x22secx3arelatedx2dworkx22x29}{8}{Related Work}.

The rest of the paper is structured as follows. In
\ChapRefLocal{t:x28part_x22secx3ainsertx22x29}{2}{Overview of Our Library}, we give an overview of how the library works
and the style of proofs we support. In \ChapRefLocal{t:x28part_x22secx3arunningx2dtimex22x29}{3}{Implicit Running Times}, we
discuss the cost model our proofs deal with. In
\ChapRefLocal{t:x28part_x22secx3aextractx2dinsertx22x29}{4}{Extracting the \Scribtexttt{insert} Function}, we explain the extraction of our
programs to OCaml. In these first three sections, we use a consistent
example that is introduced in \ChapRefLocal{t:x28part_x22secx3ainsertx22x29}{2}{Overview of Our Library}. Following this
preamble, \ChapRefLocal{t:x28part_x22secx3amonadx22x29}{5}{The Monad} walks through the definition and design
of the monad itself. \ChapRefLocalUC{t:x28part_x22secx3acasex2dstudyx22x29}{6}{Case Study} describes the results
of our case study, wherein we proved properties of a variety of
different functions. \ChapRefLocalUC{t:x28part_x22secx3asub1x22x29}{7}{Accounting for Language Primitives} discusses accounting for
the runtimes of various language primitives. Finally,
\ChapRefLocal{t:x28part_x22secx3arelatedx2dworkx22x29}{8}{Related Work} provides a detailed account of our relation
to similar projects. Our source code and other supplementary material
is available at \href{http://github.com/rfindler/395-2013}{\Snolinkurl{http://github.com/rfindler/395-2013}}.

\sectionNewpage

\Ssection{Overview of Our Library}{Overview of Our Library}\label{t:x28part_x22secx3ainsertx22x29}

The core of our library is a monad that, as part of its types, tracks
the running time of functions.  To use the library, programs must be
explicitly written using the usual return and bind monadic
operations. In return, the result type of a function can use not only
the argument values to give it a very precise specification, but also
an abstract step count describing how many primitive
operations (function calls, matches, variable references etc.) that
the function executes.

To give a sense of how code using our library looks,
we start with a definition of Braun trees~(Braun and Rem 1983)
and the insertion function where the contributions to the running time
are explicitly declared as part of the body of the function.
In the next section, we make the running times implicit
(and thus not trusted or spoofable).

Braun trees, which provide for efficient growable vectors, are a form
of balanced binary trees where the balance condition allows only a
single shape of trees for a given size. Specifically, for each
interior node, either the two children are exactly the same size or
the left child{'}s size is one larger than the right child{'}s size.

Because this invariant is so strong, explicit balance
information is not needed in the data structure that
represents Braun trees; we can use a simple binary tree
definition.

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Inductive bin{\char`\_}tree {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} {\hbox{\texttt{:}}} Set {\hbox{\texttt{:}}}=}

\Scribtexttt{{\Stttextbar} bt{\char`\_}mt}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\hbox{\texttt{:}}} bin{\char`\_}tree}

\Scribtexttt{{\Stttextbar} bt{\char`\_}node {\hbox{\texttt{:}}} A {-}{\Stttextmore} bin{\char`\_}tree {-}{\Stttextmore} bin{\char`\_}tree {-}{\Stttextmore} bin{\char`\_}tree{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

To be able to state facts about Braun trees, however,
we need the inductive \Scribtexttt{Braun} to specify which binary trees
are Braun trees (at a given size \Scribtexttt{n}).

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Inductive Braun {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} {\hbox{\texttt{:}}} (@bin{\char`\_}tree A) {-}{\Stttextmore} nat {-}{\Stttextmore} Prop {\hbox{\texttt{:}}}=}

\Scribtexttt{{\Stttextbar} B{\char`\_}mt}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\hbox{\texttt{:}}} Braun bt{\char`\_}mt 0}

\Scribtexttt{{\Stttextbar} B{\char`\_}node {\hbox{\texttt{:}}} forall (x{\hbox{\texttt{:}}}A) s s{\char`\_}size t t{\char`\_}size,}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{t{\char`\_}size {\Stttextless}= s{\char`\_}size {\Stttextless}= t{\char`\_}size+1 {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun s s{\char`\_}size {-}{\Stttextmore} Braun t t{\char`\_}size {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun (bt{\char`\_}node x s t) (s{\char`\_}size+t{\char`\_}size+1){\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

This says that the empty binary tree is a Braun tree of size
\Scribtexttt{0}, and that if two numbers \Scribtexttt{s{\char`\_}size}, \Scribtexttt{t{\char`\_}size}
are the sizes of two Braun trees \Scribtexttt{s} \Scribtexttt{t}, and if
\Scribtexttt{s{\char`\_}size {\Stttextless}= t{\char`\_}size {\Stttextless}= s{\char`\_}size + 1}, then combining
the \Scribtexttt{s} and \Scribtexttt{t} into a single tree produces
a Braun tree of size \Scribtexttt{s{\char`\_}size+t{\char`\_}size+1}.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Program Fixpoint insert {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} (i{\hbox{\texttt{:}}}A) (b{\hbox{\texttt{:}}}@bin{\char`\_}tree A)}

\Scribtexttt{{\hbox{\texttt{:}}} {\char`\{}{\hbox{\texttt{!}}} res {\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}} @bin{\char`\_}tree A {\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}} c {\hbox{\texttt{!}}}{\Stttextmore}{\hbox{\texttt{!}}}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\Scribtexttt{(forall n, Braun b n {-}{\Stttextmore} (Braun res (n+1) /{\char`\\} c = fl{\char`\_}log n + 1)) {\hbox{\texttt{!}}}{\char`\}} {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{match b with}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}mt}\mbox{\hphantom{\Scribtexttt{xxxxxxxxx}}}\Scribtexttt{={\Stttextmore} += 1; {\Stttextless}== (bt{\char`\_}node i bt{\char`\_}mt bt{\char`\_}mt)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}node j s t ={\Stttextmore} t{\textquotesingle} {\Stttextless}{-} insert j t;}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxxxxx}}}\Scribtexttt{+= 1; {\Stttextless}== (bt{\char`\_}node i t{\textquotesingle} s)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{end{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent \relax{\vspace{-3em}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3ainsertx22x29x29}Figure~1: }{t:x28counter_x28x22figurex22_x22figx3ainsertx22x29x29}Braun tree insertion}}\end{FigureMulti}

Figure~\FigureRef{1}{t:x28counter_x28x22figurex22_x22figx3ainsertx22x29x29} shows the insertion function.
Let us dig into this function, one line at a time.
It accepts an object \Scribtexttt{i} (of type \Scribtexttt{A}) to insert into
the Braun tree \Scribtexttt{b}. Its result type uses a special notation:
\Scribtexttt{{\char`\{}{\hbox{\texttt{!}}} «result id» {\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}} «simple type» {\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}} «running time id {\hbox{\texttt{!}}}{\Stttextmore}{\hbox{\texttt{!}}} «property» {\hbox{\texttt{!}}}{\char`\}}}
where the braces, exclamation marks, colons, less than, and
greater than are all fixed parts of the syntax and the
portions enclosed in « » are filled in based on the
particulars of the insert function. In this case, it is
saying that
\Scribtexttt{insert} returns a binary tree and, if the input is a
Braun tree of size \Scribtexttt{n}, then the result is a Braun tree
of size
\Scribtexttt{n+1} and the function takes \Scribtexttt{fl{\char`\_}log n + 1} steps
of computation (where \Scribtexttt{fl{\char`\_}log} computes the floor of the
base 2 logarithm).

These new \Scribtexttt{{\char`\{}{\hbox{\texttt{!}}} {\hbox{\texttt{.}}}{\hbox{\texttt{.}}}{\hbox{\texttt{.}}} {\hbox{\texttt{!}}}{\char`\}}} types are the types of
computations in the monad. The monad tracks the running
time as well as tracking the correctness property of the
function.

The body of the \Scribtexttt{insert} function begins with the
\Scribtexttt{match} expression that determines if the input Braun
tree is empty or not. If it is empty, then the function
returns a singleton tree that is obtained by calling
\Scribtexttt{bt{\char`\_}node} with two empty children. This case uses
\Scribtexttt{{\Stttextless}==}, the return operation that injects simple values
into the monad and \Scribtexttt{+=} that declares that this
operation takes a single unit of computation. That is, the
type of \Scribtexttt{+=} insists that \Scribtexttt{+=} accepts a natural number
\Scribtexttt{k} and a computation in the monad taking some number of
steps, say \Scribtexttt{n}. The result of \Scribtexttt{+=} is also a
computation in the monad just like the second argument,
except that the running time is \Scribtexttt{n+k}.

In the non{-}empty case, the insertion function recurs with
the right subtree and then builds a new tree with the subtrees
swapped. This swapping is what preserves the Braun invariant.
Since we know that the left subtree{'}s size is either equal to or one
larger than the right{'}s, when we add an element to the right and swap
the subtrees, we end up with a new tree whose left
subtree{'}s size is either equal to or one greater than the right.

The \Scribtexttt{«var» {\Stttextless}{-} «expr» ; «expr»} notation is the monadic bind
operator; using a \Scribtexttt{let}{-}style notation. The first,
right{-}hand side expression must be a computation in the monad;
the result value is pulled out of the monad and bound to
\Scribtexttt{var} for use in the body expression.
Then, as before, we return the new tree in the monad after treating
this branch as a single abstract step of computation.

We exploit Sozeau~(2006){'}s \Scribtexttt{Program} to simplify proving
that these functions have their types. In this case, we are left with two
proof obligations, one from each of the cases of the function. The first
one is:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{forall n, Braun bt{\char`\_}mt n {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun (bt{\char`\_}node i bt{\char`\_}mt bt{\char`\_}mt) (n + 1) /{\char`\\} 1 = fl{\char`\_}log n + 1}\end{SingleColumn}\end{InlineCode}

\noindent The assumption is saying that \Scribtexttt{n} is the size of the empty
Braun tree, which tells us that \Scribtexttt{n} must be
zero. So simplifying, we are asked to prove that:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Braun (bt{\char`\_}node i bt{\char`\_}mt bt{\char`\_}mt) 1 /{\char`\\} 1 = fl{\char`\_}log 0 + 1}\end{SingleColumn}\end{InlineCode}

\noindent both of which follow immediately from the definitions. This proof
request corresponds exactly to what we need to know in order for the
base case to be correct: the singleton tree is a Braun tree of size
\Scribtexttt{1} and the running time is correct on empty input.

For the second case, we are asked to prove:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{forall i j s t bt an n,}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{(forall m {\hbox{\texttt{:}}} nat, Braun t m {-}{\Stttextmore} Braun bt (m + 1) /{\char`\\} an = fl{\char`\_}log m + 1) {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun (bt{\char`\_}node j s t) n {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun (bt{\char`\_}node i bt s) (n + 1) /{\char`\\} an + 1 = fl{\char`\_}log n + 1}\end{SingleColumn}\end{InlineCode}

\noindent Thus, we may assume a slightly more general
inductive hypothesis (the inner \Scribtexttt{forall}) than we need
(it is specialized to the recursive call that \Scribtexttt{insert} makes, but
not the size of the tree) and that the tree \Scribtexttt{bt{\char`\_}node j s t} is a
Braun tree of size n. So, we must show that \Scribtexttt{bt{\char`\_}node i bt s} is a
Braun tree of size \Scribtexttt{n + 1} and that the running time is correct.

Because the size information is not present in the actual insertion
function, Coq does not know to specialize the inductive hypothesis to
the size of \Scribtexttt{t}. To clarify that, we can replace \Scribtexttt{m} with
\Scribtexttt{t{\char`\_}size} and, since we know that the tree is not empty, we can replace
\Scribtexttt{n} with \Scribtexttt{s{\char`\_}size + t{\char`\_}size + 1} and simplify to arrive at this goal:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{forall i j s t bt an s{\char`\_}size t{\char`\_}size,}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{Braun bt (t{\char`\_}size + 1) {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{an = fl{\char`\_}log t{\char`\_}size + 1 {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{Braun (bt{\char`\_}node j s t) (s{\char`\_}size + t{\char`\_}size + 1) {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{Braun (bt{\char`\_}node i bt s) (s{\char`\_}size + t{\char`\_}size + 1 + 1) /{\char`\\}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{an + 1 = fl{\char`\_}log (s{\char`\_}size + t{\char`\_}size + 1) + 1}\end{SingleColumn}\end{InlineCode}

\noindent which we can prove by using facts about logarithms
and the definition of Braun trees.

This theorem corresponds precisely to what we need to know in order to
prove that the recursive case of \Scribtexttt{insert} works. The assumptions
correspond to the facts we gain from the input to the function and
from the result of the recursive call. The conclusion corresponds to
the facts we need to establish for this case. This precision of the
obligation is thanks to \Scribtexttt{Program} and the structure of our monad.

\sectionNewpage

\Ssection{Implicit Running Times}{Implicit Running Times}\label{t:x28part_x22secx3arunningx2dtimex22x29}

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{bigtabular}{@{\bigtableleftpad}l@{}l@{}}
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{Program Fixpoint} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{Program Fixpoint insert {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} (i{\hbox{\texttt{:}}}A) (b{\hbox{\texttt{:}}}@bin{\char`\_}tree A)} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{insert {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} (i{\hbox{\texttt{:}}}A) (b{\hbox{\texttt{:}}}@bin{\char`\_}tree A) } \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{{\hbox{\texttt{:}}} {\char`\{}{\hbox{\texttt{!}}} res {\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}} @bin{\char`\_}tree A {\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}} c {\hbox{\texttt{!}}}{\Stttextmore}{\hbox{\texttt{!}}}} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{{\hbox{\texttt{:}}} @bin{\char`\_}tree A {\hbox{\texttt{:}}}=} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\Scribtexttt{insert{\char`\_}result A i b res c {\hbox{\texttt{!}}}{\char`\}} {\hbox{\texttt{:}}}=} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{match b with} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{match b with} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}mt ={\Stttextmore} } \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}mt ={\Stttextmore} } \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\Stttextless}== bt{\char`\_}node i bt{\char`\_}mt bt{\char`\_}mt} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\Scribtexttt{+= 6; } \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}node j s t ={\Stttextmore} } \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\Scribtexttt{{\Stttextless}== (bt{\char`\_}node i bt{\char`\_}mt bt{\char`\_}mt)} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{t{\textquotesingle} {\Stttextless}{-} insert j t;} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} bt{\char`\_}node j s t ={\Stttextmore} } \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\Stttextless}== bt{\char`\_}node i t{\textquotesingle} s} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\Scribtexttt{t{\textquotesingle} {\Stttextless}{-} insert j t;} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{end{\hbox{\texttt{.}}}} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\Scribtexttt{+= 9; } \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxx}}}\Scribtexttt{{\Stttextless}== (bt{\char`\_}node i t{\textquotesingle} s)} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{end{\hbox{\texttt{.}}}} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
 \\
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
 &
\begin{minipage}[c]{0.5\linewidth}
\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}} \end{minipage}
\end{bigtabular}

\noindent \relax{\vspace{-5em}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3atranslationx22x29x29}Figure~2: }{t:x28counter_x28x22figurex22_x22figx3atranslationx22x29x29}Inserting += into insert}}\end{FigureMulti}

One disadvantage to the code in the previous section is that the
running times are tangled with the body of the insertion function.
Even worse, making mistakes when writing \Scribtexttt{+=} expressions can
produce un{-}provable claims or cause our proofs about the running times
to be useless, as they will prove facts that are irrelevant
to the functions we are using.

To handle this situation, we{'}ve written a simple Coq{-}to{-}Coq
translation function that accepts functions written in our
monad without any \Scribtexttt{+=} expressions and turns them into
ones with \Scribtexttt{+=} expressions in just the right places.

Our translation function accepts a function written in the
monad, but without the monadic type on its result, and produces
one with it. For example, the \Scribtexttt{insert} function shown on the
left in figure~\FigureRef{2}{t:x28counter_x28x22figurex22_x22figx3atranslationx22x29x29} is translated into the one
on the right. As well as adding \Scribtexttt{+=} expressions, the
translation process also generates a call to \Scribtexttt{insert{\char`\_}result}
in the monadic result type. The user must define this function
separately and the translation{'}s output must be used in that
context:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition insert{\char`\_}time n {\hbox{\texttt{:}}}= 9 * fl{\char`\_}log n + 6{\hbox{\texttt{.}}}}

\Scribtexttt{Definition insert{\char`\_}result (A {\hbox{\texttt{:}}} Set) (i {\hbox{\texttt{:}}} A) (b{\hbox{\texttt{:}}}bin{\char`\_}tree) (res{\hbox{\texttt{:}}}bin{\char`\_}tree) c {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{(forall n, Braun b n {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\Scribtexttt{(Braun res (S n) /{\char`\\}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\Scribtexttt{(forall xs, SequenceR b xs {-}{\Stttextmore} SequenceR res (i{\hbox{\texttt{:}}}{\hbox{\texttt{:}}}xs)) /{\char`\\}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\Scribtexttt{c = insert{\char`\_}time n)){\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent Unlike the previous version, this one accounts for the larger constant
factors and it also includes a stricter correctness
condition. Specifically, the new conjunct uses \Scribtexttt{SequenceR} (a
proposition we wrote) to insist that if you linearize the resulting
Braun tree into a list, then it is the same as linearizing the input
and consing the new element onto the list.

Rather than develop a novel, and potentially controversial cost
semantics, we show the utility of our monad by adopting the
Rosendahl~(1989) cost model. This model treats
each function call, variable lookup, and case{-}dispatch as a single
unit of abstract time. In figure~\FigureRef{2}{t:x28counter_x28x22figurex22_x22figx3atranslationx22x29x29}, the first
return is annotated with a cost of \relax{$6$} because it
references \relax{$4$} variables, calls \relax{$1$} function,
and does \relax{$1$} case{-}dispatch. The second return is annotated
with a cost of \relax{$9$} because it references \relax{$6$}
variables (the self{-}reference is not counted), calls \relax{$2$}
functions, and does \relax{$1$} case{-}dispatch.

Our translation function is straightforward and is included in the
supplementary materials (\Scribtexttt{add{-}plusses/check{-}stx{-}errs} in
\Scribtexttt{rkt/tmonad/main{\hbox{\texttt{.}}}rkt}). Our monad could support different cost
semantics, without modification, provided a function could map them to
the program{'}s syntax in a straightforward way.

An alternative approach would be to follow
Danner et al.~(2013) and build a Coq model of a machine and
programming language. We would then define a cost judgement for this
machine and prove its soundness with respect to the machine{'}s
reduction lengths. Finally, we would show that our monadic types allow
incremental proofs of their cost results. In some sense, this {``}deep
embedding{''} would be a more direct study of cost and cost proofs, but
it would be no more directly connected with the running time of the programs,
unless we could establish a connection to the OCaml VM.

\sectionNewpage

\Ssection{Extracting the \Scribtexttt{insert} Function}{Extracting the \Scribtexttt{insert} Function}\label{t:x28part_x22secx3aextractx2dinsertx22x29}

One of the important benefits of our library is that
none of the correctness conditions and running time
infrastructure affect Coq{'}s extraction process.
In particular, our monad extracts as the identity
monad, which means that the OCaml code produced by Coq
does not require any modifications.
For example, here is how \Scribtexttt{insert} extracts:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{type {\textquotesingle}a bin{\char`\_}tree = {\Stttextbar} Bt{\char`\_}mt}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\Scribtexttt{{\Stttextbar} Bt{\char`\_}node of {\textquotesingle}a * {\textquotesingle}a bin{\char`\_}tree * {\textquotesingle}a bin{\char`\_}tree}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}

\Scribtexttt{let rec insert i = function}

\Scribtexttt{{\Stttextbar} Bt{\char`\_}mt}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxx}}}\Scribtexttt{{-}{\Stttextmore} Bt{\char`\_}node (i, Bt{\char`\_}mt, Bt{\char`\_}mt)}

\Scribtexttt{{\Stttextbar} Bt{\char`\_}node (j, s, t) {-}{\Stttextmore} Bt{\char`\_}node (i, (insert j t), s)}\end{SingleColumn}\end{InlineCode}

\noindent The only declarations we added to
aid Coq{'}s extraction was the suggestion that it should
inline the monad operations. And since the extracted
version of our monad is the identity monad, the monad
operations simply evaporate when they are inlined.

More importantly, however, note that this code does not
have any proof residue; there are no extra data{-}structures
or function arguments or other artifacts of the information
used to prove the running time correct.

\sectionNewpage

\Ssection{The Monad}{The Monad}\label{t:x28part_x22secx3amonadx22x29}

One way to account for cost is to use the monad to pair an actual
value (of type \Scribtexttt{B}) with a natural number representing the
computation{'}s current cost, and then ensure that this number is
incremented appropriately at each stage of the computation.
Unfortunately, this cost would be part of the dynamic behavior of the
algorithm. In other words, \Scribtexttt{insert x bt} would return a new tree
and a number, violating our goal of having no complexity residue in
extracted programs.

In Coq parlance, the problem is that we have a pair of two \Scribtexttt{Set}
values{---}the \Scribtexttt{B} and the \Scribtexttt{nat}{---}and \Scribtexttt{Set}s are, by
definition, part of the computational content. Instead, we need to
have a \Scribtexttt{Set} paired with something from the universe of truth
propositions, \Scribtexttt{Prop}. The trouble is finding the right proposition.

We use a new function \Scribtexttt{C} that consumes a type and a proposition
that is parameterized over values of the type and numbers. Specifically,
we define \Scribtexttt{C}:

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition C (A{\hbox{\texttt{:}}}Set) (P{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop) {\hbox{\texttt{:}}} Set {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\char`\{}a {\hbox{\texttt{:}}} A {\Stttextbar} exists (an{\hbox{\texttt{:}}}nat), (P a an){\char`\}}{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

For a given \Scribtexttt{A} and \Scribtexttt{P}, \Scribtexttt{C A P} is a dependent pair of
\Scribtexttt{a}, a value of type \Scribtexttt{A}, and a proof that there exists some
natural number \Scribtexttt{an} related to \Scribtexttt{a} by \Scribtexttt{P}.
The intention is to think of the natural number as the running
time and \Scribtexttt{P} as some specification of running time (and possibly
also correctness) specific to the particular function.
Importantly, the right{-}hand side of this pair is a proposition,
so it contributes no computational content when extracted into OCaml.
To see this in practice, consider \Scribtexttt{insert}{'}s result type:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{{\hbox{\texttt{:}}} {\char`\{}{\hbox{\texttt{!}}} res {\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}} @bin{\char`\_}tree A {\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}} c {\hbox{\texttt{!}}}{\Stttextmore}{\hbox{\texttt{!}}}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxx}}}\Scribtexttt{(forall n, Braun b n {-}{\Stttextmore} (Braun res (n+1) /{\char`\\} c = fl{\char`\_}log n + 1)) {\hbox{\texttt{!}}}{\char`\}}}\end{SingleColumn}\end{InlineCode}

This is a shorthand (using Coq{'}s \Scribtexttt{notation} construct) for the
following call to \Scribtexttt{C}, in order to avoid duplicating the type
between \Scribtexttt{{\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}}} and \Scribtexttt{{\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}}}:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{(C (@bin{\char`\_}tree A) (fun (res{\hbox{\texttt{:}}}@bin{\char`\_}tree A) (c{\hbox{\texttt{:}}}nat) ={\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{(forall n, Braun b n {-}{\Stttextmore} (Braun res (n+1) /{\char`\\} c = fl{\char`\_}log n + 1))))}\end{SingleColumn}\end{InlineCode}

One important aspect of the \Scribtexttt{C} type is that the \Scribtexttt{nat} is bound
only by an existential, and thus is not necessarily connected to the
value or the runtime. Therefore, when we know an expression has the
type \Scribtexttt{C A P}, we do not know that its running time is correct,
because the property might be about anything and the proof might
supply any \Scribtexttt{nat} to satisfy the existential.  Thus, in order to
guarantee the correct running times, we treat types of the form \Scribtexttt{C
A P} as private to the monad{'}s defining module. We build a set of
operations that can be combined in arbitrary ways but subject to the
restriction that the \Scribtexttt{nat} must actually be the running time.

The first of these operations is the monadic unit, \Scribtexttt{ret}. Suppose a
program returns an empty list, \Scribtexttt{{\Stttextless}== nil}. Such a program takes no
steps to compute, because the value is readily available. This logic
applies to all places where a computation ends. To do this, we define
\Scribtexttt{{\Stttextless}== x} to be \Scribtexttt{ret {\char`\_} {\char`\_} x {\char`\_}}, a use of the monad operator
\Scribtexttt{ret}. The underscores ask Coq to fill in well{-}typed
arguments (asking the user to provide proofs, if necessary, as we saw
in \ChapRefLocal{t:x28part_x22secx3ainsertx22x29}{2}{Overview of Our Library}).
This is the type\NoteBox{\NoteContent{The definition of \Scribtexttt{ret}, and all other
monadic operations, are in the supplementary material and our public
Github repo. The types are the most interesting part, however,
so we focus on them.}} of \Scribtexttt{ret}:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition ret (A{\hbox{\texttt{:}}}Set) (P{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop) (a{\hbox{\texttt{:}}}A) (Pa0{\hbox{\texttt{:}}}P a 0) {\hbox{\texttt{:}}} C A P{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent This specifies that \Scribtexttt{ret} will construct a \Scribtexttt{C A P} only when
given a proof, \Scribtexttt{Pa0}, that the correctness/runtime property holds
between the actual value returned \Scribtexttt{a} and the natural number
\Scribtexttt{0}. In other words, \Scribtexttt{ret} requires \Scribtexttt{P} to predict the
running time as \Scribtexttt{0}.

There are two other operations in our monad: \Scribtexttt{inc} that adds to the
count of the running time, and \Scribtexttt{bind} that combines two
computations in the monad, summing their running times. We tackle
\Scribtexttt{inc} next.

Suppose a program returns a value \Scribtexttt{a}, with property \Scribtexttt{P},
that takes exactly one step to compute. We represent such a program with the expression:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{+= 1; {\Stttextless}== a}\end{SingleColumn}\end{InlineCode}

\noindent We would like our proof obligation for this expression to be \Scribtexttt{P a
1}.  We know, however that the obligation on \Scribtexttt{{\Stttextless}==}, namely \Scribtexttt{P a
0}, is irrelevant or worse, wrong. There is a simple way out of this
bind: what if the \Scribtexttt{P} for the \Scribtexttt{ret} were different than the
\Scribtexttt{P} for of the entire expression? In code, what if the obligation
were \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{ a 0}?  At worst, such a change would be irrelevant because
there may not be a connection between \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{} and \Scribtexttt{P}. But, we can
choose a \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{} such that \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{ a 0} is the same as \Scribtexttt{P a 1}.

We previously described \Scribtexttt{P} as a relation between \Scribtexttt{A}s and
\Scribtexttt{nat}s, but in Coq this is just a function that accepts an \Scribtexttt{A}
and a \Scribtexttt{nat} and returns a proposition. So, we can make \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{} be
the function \Scribtexttt{fun a an ={\Stttextmore} P a (an+1)}. This has the effect of
transforming the runtime obligation on \Scribtexttt{ret} from what was
described above. The proof \Scribtexttt{P}\Scribtexttt{{'}}\Scribtexttt{ a 0} becomes \Scribtexttt{P a 1}. In general,
if the cost along a control{-}flow path to a \Scribtexttt{ret} has \Scribtexttt{k} units
of cost, the proof will be \Scribtexttt{P a k}. Thus, we accrue the cost inside
of the property itself.

The monadic operator \Scribtexttt{inc} encapsulates this logic and introduces \Scribtexttt{k} units of cost:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition inc (A{\hbox{\texttt{:}}}Set) k (PA {\hbox{\texttt{:}}} A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\Scribtexttt{(x{\hbox{\texttt{:}}}C A (fun x xn ={\Stttextmore} forall xm, xn + k = xm {-}{\Stttextmore} PA x xm))}

\Scribtexttt{{\hbox{\texttt{:}}} C A PA{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent In programs using our monad, we write \Scribtexttt{+= k; e}, a
shorthand for \Scribtexttt{inc {\char`\_} k {\char`\_} e}.
The key point in the definition is that the property in \Scribtexttt{x}{'}s type
is \textit{not} \Scribtexttt{PA}, but a modified function that ensures the
argument is at least \Scribtexttt{k}.

In principle, the logic for \Scribtexttt{bind} is very similar. A \Scribtexttt{bind}
represents a composition of two computations: an \Scribtexttt{A}{-}producing one
and an \Scribtexttt{A}{-}consuming, \Scribtexttt{B}{-}producing one. If we assume that the
property for \Scribtexttt{A} is \Scribtexttt{PA} and \Scribtexttt{PB} for \Scribtexttt{B}, then an attempt
at a type for \Scribtexttt{bind} is:


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition bind1 (A{\hbox{\texttt{:}}}Set) (PA{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(B{\hbox{\texttt{:}}}Set) (PB{\hbox{\texttt{:}}}B {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(am{\hbox{\texttt{:}}}C A PA) (bf{\hbox{\texttt{:}}}A {-}{\Stttextmore} C B PB)}

\Scribtexttt{{\hbox{\texttt{:}}} C B PB{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

This definition is incorrect from the cost perspective, because it
does not ensure that the cost for producing the \Scribtexttt{A} is accounted
for along with the cost of producing the \Scribtexttt{B}.

Suppose that the cost of generating the \Scribtexttt{A} was \Scribtexttt{7}, then we
should transform the property of the \Scribtexttt{B} computation to be \Scribtexttt{fun
b bn ={\Stttextmore} PB b (bn+7)}. Unfortunately, we cannot {``}look inside{''} the
\Scribtexttt{A} computation to know that it costs 7 units. Instead, we have to
show that \textit{whatever} the cost for \Scribtexttt{A} was, the cost of \Scribtexttt{B}
is still as expected. This suggests a second attempt at a definition
of \Scribtexttt{bind}: 

\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition bind2 (A{\hbox{\texttt{:}}}Set) (PA{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(B{\hbox{\texttt{:}}}Set) (PB{\hbox{\texttt{:}}}B {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(am{\hbox{\texttt{:}}}C A PA) }

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(bf{\hbox{\texttt{:}}}A {-}{\Stttextmore} C B (fun b bn ={\Stttextmore} forall an, PB b (bn+an)))}

\Scribtexttt{{\hbox{\texttt{:}}} C B PB{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

Unfortunately, this is far too strong of a statement because there are
some costs \Scribtexttt{an} that are too much. The only \Scribtexttt{an} costs that our
\Scribtexttt{bind} proof must be concerned with are those that respect the
\Scribtexttt{PA} property given the \textit{actual} value of \Scribtexttt{a} that the
\Scribtexttt{A} computation produced.  We can use a dependent type on \Scribtexttt{bf}
to capture the connection between the costs in a third attempt at the
type for \Scribtexttt{bind}.

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition bind3 (A{\hbox{\texttt{:}}}Set) (PA{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(B{\hbox{\texttt{:}}}Set) (PB{\hbox{\texttt{:}}}B {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(am{\hbox{\texttt{:}}}C A PA) }

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{(bf{\hbox{\texttt{:}}}forall (a{\hbox{\texttt{:}}}A),}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxx}}}\Scribtexttt{C B (fun b bn ={\Stttextmore} forall an, PA a an {-}{\Stttextmore} PB b (bn+an)))}

\Scribtexttt{{\hbox{\texttt{:}}} C B PB{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

This version of \Scribtexttt{bind} is complete, from a cost perspective, but
has one problem for practical theorem proving. The body of the
function \Scribtexttt{bf} has access to the value \Scribtexttt{a}, but it does not have
access to the correctness part of the property \Scribtexttt{PA}. At first
blush, the missing \Scribtexttt{PA} appears not to matter because the proof of
correctness for the result of \Scribtexttt{bf} \textit{does} have access through
the hypothesis \Scribtexttt{PA a an}, but that proof context is not available
when producing the \Scribtexttt{b} result. Instead, \Scribtexttt{bind} assumes that
\Scribtexttt{b} has already been computed. That assumption means if the proof
of \Scribtexttt{PA} is needed to compute \Scribtexttt{b}, then we will be stuck. The
most common case where \Scribtexttt{PA} is neccessary occurs when \Scribtexttt{bf}
performs non{-}structural recursion and must construct a well{-}foundness
proof to perform the recursive call. These well{-}foundness proofs
typically rely on the correctness of the \Scribtexttt{a} value. Some of the
functions we discuss in our case study in \ChapRefLocal{t:x28part_x22secx3acasex2dstudyx22x29}{6}{Case Study}
could not be written with this version of \Scribtexttt{bind}, although some could.

It is simple to incorporate the \Scribtexttt{PA} proof into the type of
\Scribtexttt{bf}, once you realize the need for it, by adding an additional
proposition argument that corresponds to the right{-}hand side of the
\Scribtexttt{C A PA} value \Scribtexttt{am}: 

\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition bind (A{\hbox{\texttt{:}}}Set) (PA{\hbox{\texttt{:}}}A {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\Scribtexttt{(B{\hbox{\texttt{:}}}Set) (PB{\hbox{\texttt{:}}}B {-}{\Stttextmore} nat {-}{\Stttextmore} Prop)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\Scribtexttt{(am{\hbox{\texttt{:}}}C A PA) }

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxx}}}\Scribtexttt{(bf{\hbox{\texttt{:}}}forall (a{\hbox{\texttt{:}}}A) (pa{\hbox{\texttt{:}}}exists an, PA a an),}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxx}}}\Scribtexttt{C B (fun b bn ={\Stttextmore} forall an, PA a an {-}{\Stttextmore} PB b (an+bn)))}

\Scribtexttt{{\hbox{\texttt{:}}} C B PB{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

When writing programs we use the notation
\Scribtexttt{«x» {\Stttextless}{-} «expr1» ; «expr2»}
as a shorthand for
\Scribtexttt{bind {\char`\_} {\char`\_} {\char`\_} {\char`\_} expr1 (fun (x {\hbox{\texttt{:}}} {\char`\_}) (am {\hbox{\texttt{:}}} {\char`\_}) ={\Stttextmore} expr2)}

Because all of the interesting aspects of these operations happen in
their types, the extractions of these operations have no interesting
dynamic content. Specifically \Scribtexttt{ret} is simply the identity
function, \Scribtexttt{inc} is a function that just returns its second argument
and \Scribtexttt{bind} applies its second argument to its first.

Furthermore, we have proven that they obey variants of the monad laws
that incorporate the proof obligations (see the file \Scribtexttt{monad/laws{\hbox{\texttt{.}}}v}
in the supplementary material). Our versions of the monad law proofs
use an auxiliary relation, written \Scribtexttt{sig{\char`\_}eqv}, rather than
equality. This relation ensures that the values returned by monadic
commands are equal and that their proofs are equivalent. In practice,
this means that although the theorems proved by expressions such as
\Scribtexttt{(m {\Stttextmore}{\Stttextmore}= ({\char`\\}x {-}{\Stttextmore} f x {\Stttextmore}{\Stttextmore}= g))} and \Scribtexttt{((m {\Stttextmore}{\Stttextmore}= f) {\Stttextmore}{\Stttextmore}= g)} are written
differently, they imply each other. In particular, for that pair of
expressions, one proves that \Scribtexttt{(n{\char`\_}m + (n{\char`\_}f + n{\char`\_}g))} is an accurate
prediction of running time and the other proves that \Scribtexttt{((n{\char`\_}m + n{\char`\_}f)
+ n{\char`\_}g)} is an accurate prediction of running time, which are
equivalant statements.

In summary, the monad works by requiring the verifier to predict the
running{-}time in the \Scribtexttt{PA} property and then prove that the actual
cost (starting at \Scribtexttt{0} and incrementing as the property passes down)
matches the prediction.

\sectionNewpage

\Ssection{Case Study}{Case Study}\label{t:x28part_x22secx3acasex2dstudyx22x29}

To better understand how applicable our monad is, we implemented a
variety of functions: search and insert for red{-}black trees, insertion
sort, merge sort, both the naive recursive version of the
\relax{$n$}th Fibonacci number function and the iterative version,
a function that inserts \relax{$m$} times into a list at position
\relax{$n$} using both lists and zippers, BigNum \Scribtexttt{add1} and
\Scribtexttt{plus}, and all of the algorithms mentioned in
Okasaki~(1997){'}s paper, \textit{Three
Algorithms on Braun Trees}. We chose these algorithms by first
selecting Okasaki{'}s papers, because the project originated in a class
and we knew Okasaki{'}s paper to be well{-}written and understandable to
undergraduates. From that initial selection, we moved to an in{-}order
traversal of Cormen et al.~(2009) looking for functional algorithms that would
challenge the framework.

To elaborate on the Braun tree algorithms, Okasaki{'}s paper contains
several versions of each of the three functions, each with different
running times, in each case culminating with efficient versions.  The
three functions are:


\noindent \begin{itemize}\atItemizeStart

\item \Scribtexttt{size}: computes the size of a Braun
tree (a linear and a log squared version)

\item \Scribtexttt{copy}: builds a Braun tree of a given size
filled entirely with a given element
(a linear, a fib $\circ$ log, a log squared, and a log time version),
and

\item \Scribtexttt{make{\char`\_}array}: converts a list into a Braun tree
(two n log n and a linear version).\end{itemize}

In total, we implemented 19 different functions using the
monad.  For all of them, we proved the expected O running times.  For
merge sort, we proved it is $\Theta$(\relax{$n \log(n)$}). For the naive
\Scribtexttt{fib}, we proved that it is $\Theta$ of itself, O(\relax{$2^n$}), and
$\Omega$(\relax{$2^{n/2}$}), all assuming that the addition operation is
constant time. For the iterative \Scribtexttt{fib}, we prove that it is
O(\relax{$n^2$}).  For the list insertion functions, we prove that
when \relax{$m$} is positive, the zipper version is O of the list
version (because the zipper version runs in O(\relax{$m + n$})
while the list version runs in O(\relax{$n * m$}).) For BigNum
arithmetic, we prove that \Scribtexttt{add1} is O(\relax{$\log(n)$}) and
that \Scribtexttt{plus} is $\Theta$(\relax{$\log(n)$}). In all cases, except for
\Scribtexttt{make{\char`\_}array{\char`\_}linear} and red{-}black tree insertion, the proofs of
running time include proof of correctness of the algorithm. Finally,
in the proofs for BigNum arithmetic and about the Fibonacci functions,
we use a simplified cost model that reduces all \Scribtexttt{inc} constants to
\relax{$1$}.  The supplementary material contains all of the Coq
code for all of the functions in our case study.

\Ssubsection{Line Counts}{Line Counts}\label{t:x28part_x22Linex5fCountsx22x29}

Our supplementary material contains a detailed account of the
lines of Coq code produced for our study. We separate the line counts
into proofs that are inside obligations (and thus correspond to
establishing that the monadic types are correct) and other lines of
proofs. In total there are 12,870 lines of code. There
are 5,321 lines that are not proofs. There are
1,895 lines of code in obligations and
5,654 lines of other proofs.

We have built a library of general proofs about the monad (such as
the monad laws), an asymptotic complexity library, a Log library, and
some common facts and definitions about Braun trees. This library
accounts for over 25\% of the code of each category.

With the exception of the \Scribtexttt{make{\char`\_}array{\char`\_}linear} and the red{-}black
tree insertion function, the proofs inside the obligations establish
the correctness of the functions and establish a basic running time
result, but not an asymptotic one in terms of O.

\begin{FigureMulti}\begin{Centerfigure}\begin{FigureInside}\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Program Fixpoint copy{\char`\_}log{\char`\_}sq {\char`\{}A{\hbox{\texttt{:}}}Set{\char`\}} (x{\hbox{\texttt{:}}}A) (n{\hbox{\texttt{:}}}nat) {\char`\{}measure n{\char`\}}}

\Scribtexttt{{\hbox{\texttt{:}}} {\char`\{}{\hbox{\texttt{!}}} res {\hbox{\texttt{!}}}{\hbox{\texttt{:}}}{\hbox{\texttt{!}}} bin{\char`\_}tree {\hbox{\texttt{!}}}{\Stttextless}{\hbox{\texttt{!}}} c {\hbox{\texttt{!}}}{\Stttextmore}{\hbox{\texttt{!}}} copy{\char`\_}log{\char`\_}sq{\char`\_}result A x n res c {\hbox{\texttt{!}}}{\char`\}} {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{match n with}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} 0}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{={\Stttextmore} += 3; {\Stttextless}== bt{\char`\_}mt}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} S n{\textquotesingle} ={\Stttextmore} t {\Stttextless}{-} copy{\char`\_}log{\char`\_}sq x (div2 n{\textquotesingle});}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\Scribtexttt{if (even{\char`\_}odd{\char`\_}dec n{\textquotesingle})}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\Scribtexttt{then (+= 13; {\Stttextless}== (bt{\char`\_}node x t t))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\Scribtexttt{else (s {\Stttextless}{-} insert x t; += 16; {\Stttextless}== (bt{\char`\_}node x s t))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{end{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent \relax{\vspace{-3em}}\end{FigureInside}\end{Centerfigure}

\Centertext{\Legend{\FigureTarget{\label{t:x28counter_x28x22figurex22_x22figx3acopyx5flogx5fsqx22x29x29}Figure~3: }{t:x28counter_x28x22figurex22_x22figx3acopyx5flogx5fsqx22x29x29}\Scribtexttt{copy{\char`\_}log{\char`\_}sq}}}\end{FigureMulti}

For example, Figure~\FigureRef{3}{t:x28counter_x28x22figurex22_x22figx3acopyx5flogx5fsqx22x29x29} is the definition of the
\Scribtexttt{copy{\char`\_}log{\char`\_}sq} function, basically mirroring Okasaki{'}s definition,
but in Coq{'}s notation. The monadic result type is


\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Definition copy{\char`\_}log{\char`\_}sq{\char`\_}result (A{\hbox{\texttt{:}}}Set) (x{\hbox{\texttt{:}}}A) (n{\hbox{\texttt{:}}}nat) (b{\hbox{\texttt{:}}}@bin{\char`\_}tree A) (c{\hbox{\texttt{:}}}nat) {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Braun b n /{\char`\\} SequenceR b (mk{\char`\_}list x n) /{\char`\\} c = copy{\char`\_}log{\char`\_}sq{\char`\_}time n{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent which says that the result is a Braun tree whose size matches the
input natural number, that linearizing the resulting tree
produces the input list, and that the running time is given by
the function \Scribtexttt{copy{\char`\_}log{\char`\_}sq{\char`\_}time}.

The running time function, however, is defined in parallel to
\Scribtexttt{copy{\char`\_}log{\char`\_}sq} itself, not as the product of the logs: 

\noindent \begin{InlineCode}\begin{SingleColumn}\Scribtexttt{Program Fixpoint copy{\char`\_}log{\char`\_}sq{\char`\_}time (n{\hbox{\texttt{:}}}nat) {\char`\{}measure n{\char`\}} {\hbox{\texttt{:}}}=}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{match n with}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} 0}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{={\Stttextmore} 3}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{{\Stttextbar} S n{\textquotesingle} ={\Stttextmore} if (even{\char`\_}odd{\char`\_}dec n{\textquotesingle})}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\Scribtexttt{then 13 + copy{\char`\_}log{\char`\_}sq{\char`\_}time (div2 n{\textquotesingle})}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxx}}}\Scribtexttt{else 16 + copy{\char`\_}log{\char`\_}sq{\char`\_}time (div2 n{\textquotesingle}) + insert{\char`\_}time (div2 n{\textquotesingle})}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{end{\hbox{\texttt{.}}}}\end{SingleColumn}\end{InlineCode}

\noindent  This parallel
definition allows a straightforward proof that \Scribtexttt{copy{\char`\_}log{\char`\_}sq}{'}s
running time is \Scribtexttt{copy{\char`\_}log{\char`\_}sq{\char`\_}time}, but leaves as a separate
issue the proof that \Scribtexttt{copy{\char`\_}log{\char`\_}sq{\char`\_}time} is O(\relax{$\log^2n$}).
There are 56 lines of proof to guarantee the result type of
the function is correct and an additional 179 lines to prove that that
\Scribtexttt{copy{\char`\_}log{\char`\_}sq{\char`\_}time} is O(\relax{$\log^2n$}).

For simple functions (those with linear running time except
\Scribtexttt{make{\char`\_}array{\char`\_}linear}), the running time can be expressed directly in
the monadic result (with precise constants). However, for most of the
functions the running time is first expressed precisely in a manner
that matches the structure of the function and then that running time
is proven to correspond to some asymptotic complexity, as with
\Scribtexttt{copy{\char`\_}log{\char`\_}sq}.

\Ssubsection{Extraction}{Extraction}\label{t:x28part_x22Extractionx22x29}

The extracted functions naturally fall into three categories.

In the first category are functions that recur on the natural
structure of their inputs, e.g., functions that process lists from the
front, functions that process trees by
processing the children and combining the result, and so on. In the
second category are functions that recursively process numbers by
counting down by one from a given number.  In the third category are
functions that {``}skip{''} over some of their inputs. For example,
some functions recur on natural numbers by dividing the
number by 2 instead of subtracting one, and merge sort recurs by
dividing the list in half at each step.

Functions in the first category extract into precisely the OCaml code
that you would expect, just like \Scribtexttt{insert}, as discussed in
\ChapRefLocal{t:x28part_x22secx3ainsertx22x29}{2}{Overview of Our Library}.

Functions in the second category could extract like the first, except
because we extract Coq{'}s \Scribtexttt{nat} type, which is based on Peano
numerals, into OCaml{'}s \Scribtexttt{big{\char`\_}int} type, which has a different
structure, a natural \Scribtexttt{match} expression in Coq becomes a more
complex pattern in OCaml. A representative example of this pattern is
\Scribtexttt{zip{\char`\_}rightn}. Here is the extracted version:

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{let rec zip{\char`\_}rightn n z =}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{(fun fO fS n {-}{\Stttextmore} if (eq{\char`\_}big{\char`\_}int n zero{\char`\_}big{\char`\_}int) then fO () else fS (pred{\char`\_}big{\char`\_}int n))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{(fun {\char`\_} {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{z)}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{(fun np {-}{\Stttextmore}}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{zip{\char`\_}rightn np (zip{\char`\_}right z))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{n}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\end{SingleColumn}\end{InlineCode}

The body of this function is equivalent to a single conditional that
returns \Scribtexttt{z} when \Scribtexttt{n} is \Scribtexttt{0} and recursively calls
\Scribtexttt{zip{\char`\_}rightn} on \Scribtexttt{n{-}1} otherwise. This artifact in the extraction
is simply a by{-}product of the mismatch between \Scribtexttt{nat} and
\Scribtexttt{big{\char`\_}int}. We expect that this artifact can be automatically
removed by the OCaml compiler. This transformation into the single
conditional corresponds to modest inlining, since \Scribtexttt{fO} and \Scribtexttt{fS}
occur exactly once and are constants.

Functions in the third category, however, are more complex. They
extract into code that is cluttered by Coq{'}s support for non{-}simple
recursion schemes. Because each function in Coq must be proven to be
well{-}defined and to terminate on all inputs, functions that don{'}t
simply follow the natural recursive structure of their input must have
supplemental arguments that record the decreasing nature of their
input. After extraction, these additional arguments clutter the OCaml
code with useless data structures equivalent to the original set of
arguments.

The function \Scribtexttt{cinterleave} is one such function. Here is the
extracted version:

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{let rec cinterleave{\char`\_}func x =}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{let e = let a,p = let x0,h = x in h in a in}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{let o = let x0,h = let x0,h = x in h in h in}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{let cinterleave0 = fun e0 o0 {-}{\Stttextmore} let y = {\char`\_}{\char`\_},(e0,o0) in cinterleave{\char`\_}func y in}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{(match e with}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\Stttextbar} Nil {-}{\Stttextmore} o}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxx}}}\Scribtexttt{{\Stttextbar} Cons (x0, xs) {-}{\Stttextmore} Cons (x0, (cinterleave0 o xs)))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\end{SingleColumn}\end{InlineCode}

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{let cinterleave e o =}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xx}}}\Scribtexttt{Obj{\hbox{\texttt{.}}}magic (cinterleave{\char`\_}func ({\char`\_}{\char`\_},((Obj{\hbox{\texttt{.}}}magic e),(Obj{\hbox{\texttt{.}}}magic o))))}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{x}}}\end{SingleColumn}\end{InlineCode}

All of the extra pieces beyond what was written in the original
function are useless. In particular, the argument to
\Scribtexttt{cinterleave{\char`\_}func} is a three{-}deep nested pair containing \Scribtexttt{{\char`\_}{\char`\_}}
and two lists. The \Scribtexttt{{\char`\_}{\char`\_}} is a constant that is defined at the top of
the extraction file that is never used for anything and behaves like
\Scribtexttt{unit}. That piece of the tuple corresponds to a proof that the
combined length of the two lists is decreasing. The function starts by
destructuring this complex argument to extract the two lists, \Scribtexttt{e}
and \Scribtexttt{o}. Next it constructs a version of the function,
\Scribtexttt{cinterleave0}, that recovers the natural two argument function for
use recursively in the body of the \Scribtexttt{match} expression. Finally,
this same two argument interface is reconstructed a second time,
\Scribtexttt{cinterleave}, for external applications. The external interface
has an additional layer of strangeness in the form of applications of
\Scribtexttt{Obj{\hbox{\texttt{.}}}magic} which can be used to coerce types, but here is simply
the identity function on values and in the types. These calls
correspond to use of \Scribtexttt{proj1{\char`\_}sig} in Coq to extract the value from a
Sigma type and are useless and always successful in OCaml.

All together, the OCaml program is equivalent to:

\begin{InlineCode}\begin{SingleColumn}\Scribtexttt{let rec cinterleave e o =}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxx}}}\Scribtexttt{match e with {\Stttextbar} Nil}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxx}}}\Scribtexttt{{-}{\Stttextmore} o}

\Scribtexttt{}\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxx}}}\Scribtexttt{{\Stttextbar} Cons (x, xs) {-}{\Stttextmore} Cons (x, (cinterleave o xs))}\end{SingleColumn}\end{InlineCode}

This is exactly the Coq program and idiomatic OCaml code.  Unlike the
second category, it is less plausible that the OCaml compiler already
performs this optimization and removes the superfluity from the Coq
extraction output. However, it is plausible that such an optimization
pass could be implemented, since it corresponds to inlining,
de{-}tupling, and removing an unused \Scribtexttt{unit}{-}like argument. In
summary, the presence of these useless terms is unrelated to our
running time monad, but is an example of the sort of verification residue
we wish to avoid and do successfully avoid in the case of the running
time obligations.

The functions in the first category are: \Smaller{\Scribtexttt{insert},
\Scribtexttt{size{\char`\_}linear}, \Scribtexttt{size}, \Scribtexttt{make{\char`\_}array{\char`\_}naive}, \Scribtexttt{foldr},
\Scribtexttt{make{\char`\_}array{\char`\_}naive{\char`\_}foldr}, \Scribtexttt{unravel}, \Scribtexttt{to{\char`\_}list{\char`\_}naive},
 \Scribtexttt{isort}{'}s \Scribtexttt{insert}, \Scribtexttt{isort}, \Scribtexttt{clength}, \relax{\\} \Scribtexttt{minsert{\char`\_}at},
\Scribtexttt{to{\char`\_}zip}, \Scribtexttt{from{\char`\_}zip}, \Scribtexttt{zip{\char`\_}right}, \Scribtexttt{zip{\char`\_}left},
\Scribtexttt{zip{\char`\_}insert}, \Scribtexttt{zip{\char`\_}minsert}, \Scribtexttt{minsertz{\char`\_}at}, \relax{\\} \Scribtexttt{bst{\char`\_}search},
\Scribtexttt{rbt{\char`\_}blacken}, \Scribtexttt{rbt{\char`\_}balance}, \Scribtexttt{rbt{\char`\_}insert}}.
The functions in the second category are: \Smaller{\Scribtexttt{fib{\char`\_}rec}, \Scribtexttt{fib{\char`\_}iter},
\Scribtexttt{sub1}, \Scribtexttt{mergesort}{'}s \Scribtexttt{split}, \Scribtexttt{insert{\char`\_}at},
\Scribtexttt{zip{\char`\_}rightn}, \Scribtexttt{zip{\char`\_}leftn}, \Scribtexttt{add1}, \Scribtexttt{tplus}}.
The functions in the third category are: \Smaller{\Scribtexttt{copy{\char`\_}linear},
\Scribtexttt{copy{\char`\_}fib}, \Scribtexttt{copy{\char`\_}log{\char`\_}sq}, \Scribtexttt{copy2}, \Scribtexttt{diff},
\Scribtexttt{make{\char`\_}array{\char`\_}td}, \Scribtexttt{cinterleave}, \Scribtexttt{merge}, \Scribtexttt{mergesort}}. Some
of the functions in the second category are also in the third
category.

\sectionNewpage

\Ssection{Accounting for Language Primitives}{Accounting for Language Primitives}\label{t:x28part_x22secx3asub1x22x29}

Rosendahl~(1989){'}s cost function counts all
primitive functions as constant (simply because it counts a call as
unit time and then doesn{'}t process the body). For most primitives,
this is the right behavior. For example, field selection
functions (e.g., \Scribtexttt{car} and \Scribtexttt{cdr}) are certainly constant
time. Structure allocation functions (e.g., \Scribtexttt{cons}) are usually
constant time when using a two{-}space copying collector, as most
garbage{-}collected languages do. Occasionally, allocation triggers
garbage collection, which we can assume amortized constant time (but not
something our framework handles).

More interestingly, and more often overlooked, however, are
numeric primitives. In a language implementation with
BigNums, integers are generally represented as a list of
digits in some large base and grade{-}school arithmetic
algorithms implement the various operations.
Most of these operations do not take constant time.

If we assume that the base is a power of 2\NoteBox{\NoteContent{This is the case if BigNums are represented as lists of bits}},
then division by 2, evenness testing, and checking to see if a number is equal to 0 are all
constant{-}time operations. The algorithms in our study use two other
numeric operations: \Scribtexttt{+} and \Scribtexttt{sub1}
(not counting the abstract comparison in the sorting functions).

In general, addition of BigNums is not constant time. However, certain
uses of addition can be replaced by constant{-}time bit operations. For
instance, doubling and adding 1 can be replaced by a specialized
operation that conses a \Scribtexttt{1} on the front of the
bitstring. Fortunately, every time we use addition in one of the
functions in our Braun library, the operation can be replaced by one
of these efficient operations.

One of the more interesting uses is in the linear version of
\Scribtexttt{size}, which has the sum \Scribtexttt{lsize+rsize+1} where \Scribtexttt{lsize} and
\Scribtexttt{rsize} are the sizes of two subtrees of a Braun tree. This
operation, at first glance, doesn{'}t seem to take constant{-}time. But
the Braun invariant tells us that \Scribtexttt{lsize} and \Scribtexttt{rsize} are either
equal, or that \Scribtexttt{lsize} is \Scribtexttt{rsize+1}. Accordingly, this operation
can be replaced with either \Scribtexttt{lsize*2+1} or \Scribtexttt{lsize*2}, both of
which are constant{-}time operations. Checking to see which case applies
is also constant time: if the numbers are the same, the digits at the
front of the respective lists will be the same and if they differ by
\Scribtexttt{1}, those digits will be different.

The uses of addition in \Scribtexttt{fib}, however, are not constant time. We
did not account for the time of additions in the recursive implementation
of \Scribtexttt{fib}. We have proved, however, that the iterative \Scribtexttt{fib} function,
which requires linear time when additions are not counted, requires
quadratic time when we properly account for primitive operations.

Our implementation of addition has a run time that is linear in the
number of bits of its input. Using this fact, we can prove
that iterative \Scribtexttt{fib} has a run time that is asymptotic to the square of its input.
To prove that \Scribtexttt{fib}{'}s run time is bounded below by \relax{$n^2$}, we first observe that for all
\relax{$ n \geq 6$} we have that \relax{$ 2^{n/2} \leq fib(n)$}.
In the \relax{$n$}th iteration of the loop, \Scribtexttt{fib} adds numbers with
\relax{$\frac{n}{2}$} bits in their binary representation, which
takes time on the order of \relax{$\frac{n}{2}$}.
For large enough \relax{$n$}, this implies that the run time of the
additions in the iterative \Scribtexttt{fib} function are bounded below by
\relax{$\frac{1}{2}(6 + 7 + \cdots + n$}). This sum has a quadratic lower bound.
Since the other primitives used in calculating \Scribtexttt{fib}
run in constant time, the run time is dominated by the addition operations,
thus the run time of \Scribtexttt{fib} is bounded below by a factor of \relax{$n^2$}.

A similar argument shows that the run time of \Scribtexttt{fib} has a quadratic upper bound.
Combining these two results proves that the run time of the iterative version of \Scribtexttt{fib}
is asymptotically \relax{$n^2$} when we account for primitive operations.
The supplementary material contains proofs of these facts in Coq (\Scribtexttt{fib/fib{\char`\_}iter{\hbox{\texttt{.}}}v}).

Although our analysis of \Scribtexttt{fib} properly accounts for addition, it
does not consider all language primitives. Specifically, the above analysis
of the \Scribtexttt{fib} function ignores the subtraction that occurs
in each iteration of the loop. For example, in the extracted OCaml code  for
\Scribtexttt{fib}, pattern matching against \Scribtexttt{S n} becomes a call to
the \Scribtexttt{pred{\char`\_}big{\char`\_}int} function. Subtracting 1 from a number represented in binary
requires more than constant time; \Scribtexttt{sub1} may need to traverse the entire
number to compute its predecessor.

To be certain that the non{-}constant run time of \Scribtexttt{sub1} does not affect our
calculation of \Scribtexttt{fib}{'}s run time, we argue that the implicit subtractions
in the implementation of \Scribtexttt{fib} take amortized constant time.
Although subtraction by 1 is not always a constant time operation, it does require
constant time on half of its possible inputs. On any odd number represented
in binary, subtracting by 1 is a constant time operation. It follows
that any number equivalent to 2 modulo 4 will require 2 units of time
to perform the \Scribtexttt{sub1} operation because \Scribtexttt{sub1} will terminate after two
iterations. In general, there is a
\relax{\(\frac{1}{2^n}\)}
chance that \Scribtexttt{sub1} terminates after
\relax{\(n\)}
iterations. To account for all uses of \Scribtexttt{sub1} in the implementation of
\Scribtexttt{fib}, we note that we will perform the \Scribtexttt{sub1} operation on each number
from 1 to \relax{$n$}. This gives a cost in terms of the iterations required by
\Scribtexttt{sub1} that is bounded above by
\relax{$n*(\frac{1}{2} + \frac{2}{4} + \frac{3}{8} + \cdots + \frac{n}{2^n} + \cdots$)}.
One can show that this infinite sum converges to \relax{$2*n$}, thus for a sequence of
\relax{$n$} \Scribtexttt{sub1} operations this shows
that subtraction implicit in the definition of \Scribtexttt{fib} requires amortized constant time.
Overall, the run time of the additions performed by \Scribtexttt{fib}
will dwarf the time required by subtraction. This justifies the fact that we do not
explicitly consider the time taken by \Scribtexttt{sub1} operations.

Although we can account for the recursion pattern using \Scribtexttt{sub1} described above that
counts down from \Scribtexttt{n} to \Scribtexttt{0}, there are several other recursive uses of \Scribtexttt{sub1}
found in our library. For example, our implementations of \Scribtexttt{copy2} and \Scribtexttt{copy{\char`\_}insert}
loop by subtracting \Scribtexttt{1} then dividing by \Scribtexttt{2}. As for \Scribtexttt{fib}, we have not explicitly
accounted for these other uses of \Scribtexttt{sub1}. We do, however, believe that the overhead of
using \Scribtexttt{sub1} in these functions does not change their asymptotic complexity, but we have
verified this only by testing and informal arguments.

\sectionNewpage

\Ssection{Related Work}{Related Work}\label{t:x28part_x22secx3arelatedx2dworkx22x29}

The most closely related work to ours is
Danielsson~(2008),
which presents a monad that carries a notion of abstract time. Unlike
our monad, his does not carry an invariant {--} in our terms his
construction does not have the \Scribtexttt{P} argument.  In our opinion,
figuring out the design of monad operations that support the \Scribtexttt{P}
argument is our major technical advance.  Accordingly, his system
cannot specify the running time of many of the Braun functions, since
the size information is not available without the additional
assumption of Braunness. Of course, one can bake the Braun invariants
into the Braun data{-}structure itself, which would provide them to his
monad via the function arguments, but this restricts the way the code
is written, leaves residue in the extracted code, and moves the
implementation away from an idiomatic style.  Also, his monad leaves
natural numbers in the extracted code; avoiding that is a major goal
of this work.

While Crary and Weirich~(2000){'}s work does not
leverage the full expressiveness of a theorem proving system
like Coq{'}s, it does share a similar resemblance to our approach.
Also like
Danielsson~(2008){'}s
and unlike ours, it does not provide a place to carry an
invariant of the data structures that can be used to
establish running times.

Weegen and McKinna~(2008)
give a proof of the average case complexity of Quicksort
in Coq. They too use monads, but design a monad that is
specially tailored to counting only comparison operations.
They side{-}step the extraction problem by abstracting the
implementation over a monad transformer and use one monad
for proving the correct running times and another for
extraction.

Xi and Pfenning first seriously studied the
idea of using dependent types to describe invariants of
data structures in practical programming
languages~(Xi 1999a,b; Xi and Pfenning 1999)
and, indeed, even used Braun trees as
an example in the DML language, which could
automatically prove that, for example, \Scribtexttt{size{\char`\_}log{\char`\_}sq} is
correct.

Filli\^{a}tre and Letouzey~(2004) implemented a number of
balanced binary tree implementations in Coq with proofs of
correctness (but not running time), with the goal of high{-}quality
extraction. They use an {``}external{''} approach, where the types
do not carry the running time information, which makes the proofs
more complex.

Swierstra~(2009){'}s Hoare state monad is like our
monad in that it exploits monadic structure to
make proof obligations visible at the right moments. However,
the state used in their monad has computational content and thus
is not erased during extraction.

Chargu\'{e}raud~(2010)
and Chargu\'{e}raud and Pottier~(2015){'}s characteristic formula
generator seems to produce Coq code with obligations similar to what
our monad produces, but it does not consider running time.

Others have explored automatic techniques for proving that programs
have particular resource bounds using a variety of
techniques~(Gulwani et al. 2009; Hoffmann and Shao 2015; Hofmann and Jost 2003; Hughes and Pareto 1999) These approaches are all weaker than our
approach, but provide more automation.

Similarly, others have explored different approaches for accounting for
various resource bounds and costs, but we do not provide any
contribution in this area. Instead, we take an off{-}the{-}shelf cost
semantics (Rosendahl~(1989){'}s) and use it. We
believe our approach applies to other cost models.

We have consistently used the word {``}monad{''} to describe what our
library provides and believe that that is a usefully evocative word to
capture the essence of our library. However, they are not technically
monads for two reasons. First, the monad laws are written using an
equality, but we use an equivalence relation appropriate to our
type. Second, our types have more parameters than the single parameter
used in monads, due to the proof information residing in the types, so
our {``}monad{''} is actually a generalized form of a monad, a
specialization of Atkey~(2009){'}s or
Altenkirch et al.~(2010){'}s. Swierstra~(2009) and
Swamy et al.~(2013) follow this same evocative naming convention.

Our code uses Sozeau~(2006){'}s \Scribtexttt{Program} facility in Coq for
writing dependently{-}typed programs by separating idiomatic code and
detail{-}oriented proofs in the program source. Without \Scribtexttt{Program},
our programs would have to mix the running time proofs in with the
program, which would greatly obscure the code{'}s connection to the
original algorithm, as one does in
Danielsson~(2008).

We have experimented with supporting proofs about imperative programs
by combining our monad{'}s types with a variation of the
Swierstra~(2009) and Swamy et al.~(2013) monads. The
types and proofs work out, but are considerably more complicated, due
in part to the complexity of proofs about imperative programs. We
consider it future work to study whether there is a more
elegant approach and develop a detailed case study.

\noindent{}
\textbf{Acknowledgments.}
Thanks to reviewers of previous versions of this paper. Thanks to
Neil Toronto for help with the properties
of integer logarithms (including efficient
implementations of them).
This work grew out of a PL seminar at Northwestern;
thanks to
Benjamin English,
Michael Hueschen,
Daniel Lieberman,
Yuchen Liu,
Kevin Schwarz,
Zach Smith, and
Lei Wang
for their feedback on early versions of the work.

\sectionNewpage

\Ssectionstarx{Bibliography}{Bibliography}\label{t:x28part_x22docx2dbibliographyx22x29}

\begin{AutoBibliography}\begin{SingleColumn}\label{t:x28autobib_x22Thorsten_Altenkirchx2c_James_Chapmanx2c_and_Tarmo_UustaluMonads_Need_Not_Be_EndofunctorsIn_Procx2e_Foundations_of_Software_Science_and_Computation_Structure2010x22x29}\Autobibentry{Thorsten Altenkirch, James Chapman, and Tarmo Uustalu. Monads Need Not Be Endofunctors. In \textit{Proc. Foundations of Software Science and Computation Structure}, 2010.}

\label{t:x28autobib_x22Robert_AtkeyParameterised_Notions_of_ComputationJFP_19x283x2d4x292009x22x29}\Autobibentry{Robert Atkey. Parameterised Notions of Computation. \textit{JFP} 19(3{-}4), 2009.}

\label{t:x28autobib_x22W_Braun_and_M_RemA_Logarithmic_Implementation_of_Flexible_ArraysEindhoven_University_of_Technologyx2c_MR83x2f41983x22x29}\Autobibentry{W Braun and M Rem. A Logarithmic Implementation of Flexible Arrays. Eindhoven University of Technology, MR83/4, 1983.}

\label{t:x28autobib_x22Arthur_Charguxe9raudCharacteristic_Formulae_for_Mechanized_Program_VerificationPhD_dissertationx2c_Universitxe9_Paris_Diderot_x28Paris_7x292010x22x29}\Autobibentry{Arthur Chargu\'{e}raud. Characteristic Formulae for Mechanized Program Verification. PhD dissertation, Universit\'{e} Paris Diderot (Paris 7), 2010.}

\label{t:x28autobib_x22Arthur_Charguxe9raud_and_Franxe7ois_PottierMachinex2dchecked_verification_of_the_correctness_and_amortized_complexity_of_an_efficient_unionx2dfind_implementationIn_Procx2e_ITP2015x22x29}\Autobibentry{Arthur Chargu\'{e}raud and Fran\c{c}ois Pottier. Machine{-}checked verification of the correctness and amortized complexity of an efficient union{-}find implementation. In \textit{Proc. ITP}, 2015.}

\label{t:x28autobib_x22Thomas_Hx2e_Cormenx2c_Charles_Ex2e_Leisersonx2c_Ronald_Lx2e_Rivestx2c_and_Clifford_SteinIntroduction_to_Algorithms_x283rd_Editionx29MIT_Press2009x22x29}\Autobibentry{Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms (3rd Edition). MIT Press, 2009.}

\label{t:x28autobib_x22Karl_Crary_and_Stephanie_WeirichResource_bound_certificationIn_Procx2e_POPL2000x22x29}\Autobibentry{Karl Crary and Stephanie Weirich. Resource bound certification. In \textit{Proc. POPL}, 2000.}

\label{t:x28autobib_x22Scott_Ax2e_Crosby_and_Dan_Sx2e_WallachDenial_of_Service_via_Algorithmic_Complexity_AttacksIn_Procx2e_USENIX_Security_Symposium2003x22x29}\Autobibentry{Scott A. Crosby and Dan S. Wallach. Denial of Service via Algorithmic Complexity Attacks. In \textit{Proc. USENIX Security Symposium}, 2003.}

\label{t:x28autobib_x22Nils_Anders_DanielssonLightweight_Semiformal_Time_Complexity_Analysis_for_Purely_Functional_Data_StructuresIn_Procx2e_POPL2008x22x29}\Autobibentry{Nils Anders Danielsson. Lightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures. In \textit{Proc. POPL}, 2008.}

\label{t:x28autobib_x22Norman_Dannerx2c_Jennifer_Paykinx2c_and_James_Sx2e_RoyerA_Static_Cost_Analysis_for_a_Higherx2dorder_LanguageIn_Procx2e_Workshop_on_Programming_Languages_meets_Program_Verification2013x22x29}\Autobibentry{Norman Danner, Jennifer Paykin, and James S. Royer. A Static Cost Analysis for a Higher{-}order Language. In \textit{Proc. Workshop on Programming Languages meets Program Verification}, 2013.}

\label{t:x28autobib_x22Jeanx2dChristophe_Fillixe2tre_and_Pierre_LetouzeyFunctors_for_Proofs_and_ProgramsIn_Procx2e_ESOP2004x22x29}\Autobibentry{Jean{-}Christophe Filli\^{a}tre and Pierre Letouzey. Functors for Proofs and Programs. In \textit{Proc. ESOP}, 2004.}

\label{t:x28autobib_x22Sumit_Gulwanix2c_Krishna_Kx2e_Mehrax2c_and_Trishul_ChilimbiSPEEDx3a_Precise_and_Efficient_Static_Estimation_of_Program_Computational_ComplexityIn_Procx2e_POPL2009x22x29}\Autobibentry{Sumit Gulwani, Krishna K. Mehra, and Trishul Chilimbi. SPEED: Precise and Efficient Static Estimation of Program Computational Complexity. In \textit{Proc. POPL}, 2009.}

\label{t:x28autobib_x22Jan_Hoffmann_and_Zhong_ShaoAutomatic_Static_Cost_Analysis_for_Parallel_ProgramsIn_Procx2e_ESOP2015x22x29}\Autobibentry{Jan Hoffmann and Zhong Shao. Automatic Static Cost Analysis for Parallel Programs. In \textit{Proc. ESOP}, 2015.}

\label{t:x28autobib_x22Martin_Hofmann_and_Steffen_JostStatic_prediction_of_heap_space_usage_for_firstx2dorder_functional_programsIn_Procx2e_POPL2003x22x29}\Autobibentry{Martin Hofmann and Steffen Jost. Static prediction of heap space usage for first{-}order functional programs. In \textit{Proc. POPL}, 2003.}

\label{t:x28autobib_x22John_Hughes_and_Lars_ParetoRecursion_and_Dynamic_Datax2dstructures_in_bounded_spacex3a_Towards_Embedded_ML_ProgrammingIn_Procx2e_ICFP1999x22x29}\Autobibentry{John Hughes and Lars Pareto. Recursion and Dynamic Data{-}structures in bounded space: Towards Embedded ML Programming. In \textit{Proc. ICFP}, 1999.}

\label{t:x28autobib_x22Chris_OkasakiThree_Algorithms_on_Braun_TreesJFP_7x286x291997x22x29}\Autobibentry{Chris Okasaki. Three Algorithms on Braun Trees. \textit{JFP} 7(6), 1997.}

\label{t:x28autobib_x22Mads_RosendahlAutomatic_Complexity_AnalysisIn_Procx2e_Intlx2e_Conference_on_Functional_Programming_Languages_And_Computer_Architecture1989x22x29}\Autobibentry{Mads Rosendahl. Automatic Complexity Analysis. In \textit{Proc. Intl. Conference on Functional Programming Languages And Computer Architecture}, 1989.}

\label{t:x28autobib_x22Matthieu_SozeauSubset_Coercions_in_CoqIn_Procx2e_TYPES2006x22x29}\Autobibentry{Matthieu Sozeau. Subset Coercions in Coq. In \textit{Proc. TYPES}, 2006.}

\label{t:x28autobib_x22Nikhil_Swamyx2c_Joel_Weinbergerx2c_Cole_Schlesingerx2c_Juan_Chenx2c_and_Benjamin_LivshitsVerifying_Higherx2dorder_Programs_with_the_Dijkstra_MonadIn_Procx2e_PLDI2013x22x29}\Autobibentry{Nikhil Swamy, Joel Weinberger, Cole Schlesinger, Juan Chen, and Benjamin Livshits. Verifying Higher{-}order Programs with the Dijkstra Monad. In \textit{Proc. PLDI}, 2013.}

\label{t:x28autobib_x22Wouter_SwierstraA_Hoare_Logic_for_the_State_MonadIn_Procx2e_TPHOLS2009x22x29}\Autobibentry{Wouter Swierstra. A Hoare Logic for the State Monad. In \textit{Proc. TPHOLS}, 2009.}

\label{t:x28autobib_x22Eelis_van_der_Weegen_and_James_McKinnaA_Machinex2dChecked_Proof_of_the_Averagex2dCase_Complexity_of_Quicksort_in_CoqIn_Procx2e_TYPES2008x22x29}\Autobibentry{Eelis van der Weegen and James McKinna. A Machine{-}Checked Proof of the Average{-}Case Complexity of Quicksort in Coq. In \textit{Proc. TYPES}, 2008.}

\label{t:x28autobib_x22Hongwei_XiDependently_Typed_Data_StructuresIn_Procx2e_Workshop_on_Algorithmic_Aspects_of_Advanced_Programming_Languages1999x22x29}\Autobibentry{Hongwei Xi. Dependently Typed Data Structures. In \textit{Proc. Workshop on Algorithmic Aspects of Advanced Programming Languages}, 1999a.}

\label{t:x28autobib_x22Hongwei_XiDependently_Types_in_Practical_ProgrammingPhD_dissertationx2c_Carnegie_Mellon_University1999x22x29}\Autobibentry{Hongwei Xi. Dependently Types in Practical Programming. PhD dissertation, Carnegie Mellon University, 1999b.}

\label{t:x28autobib_x22Hongwei_Xi_and_Frank_PfenningDependently_Types_in_Practical_ProgrammingIn_Procx2e_POPL1999x22x29}\Autobibentry{Hongwei Xi and Frank Pfenning. Dependently Types in Practical Programming. In \textit{Proc. POPL}, 1999.}\end{SingleColumn}\end{AutoBibliography}

\postDoc
\end{document}
