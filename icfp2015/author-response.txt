Reviewer E seems to have a technical misunderstanding related to the
comment about the associativity law and the use of sig_eqv in our
proofs.

The reviewer writes that our paper assigns

 (m >>= (\x -> f x >>= g)) and
 ((m >>= f) >>= g)

different costs. This is not correct. These two expressions are
assigned the same costs. The reviewer is correct that there is a
difference between these two expressions, however: the proofs for
those costs will have to be written differently. Simply put, one will
be a proof about (n_m + (n_f + n_g)) and the other will be a proof
about ((n_m + n_f) + n_g) where n_X is the running time of computation
X. In Coq, these proofs are not equal, but they are equivalent, which
we express through sig_eqv.

The review claims that because sig_eqv does not check that `m` and `n`
(the running times of two computations under an existential) are not
equal and thus we do not know that the monad laws preserve running
time. First, an essential part of our approach is to ensure that it is
not possible to extract the values of `m` and `n` to compare them (or
else we would lose the nice extraction). Despite that, we can still
prove that the running times are the same. The reason is that the
monad laws are parameterized over an arbitrary running time
property. This includes a property that embeds a simple constant,
e.g., (fun result cost => cost = 27). Our monad law proofs show that
even the proof of such a specific property can be "ported" from one
monadic computation to another. In the case of associativity, this is
almost as simple as using the associativity of addition.

Most of the reviewers suggest that scholarly context of the paper is
poorly written: on reflection we agree. We will improve our write
up. In the meantime, we think that the characterization of our
contribution in review E is well-explained. (Thanks!)

Other questions:

A: constant time of doubling works for any bignum representation that
uses a base that is a power of 2, something that gnu gmp does, and gmp
is the standard in bignum libraries.

B: program is a standard part of Coq that we found especially useful
in our work; it is worth investigating if you've not used it before.

C: Are you saying that runtime-complexity is less interesting than
correctness? Or that we have not established a good-enough connection
to the machine? Thanks if you reply! (see also USENIX03 Crosby).

D asks many useful questions that we plan in future writeups (thanks!); 
  here are some short answers:
+ Braun trees provide growable vectors.
+ All the definitions are in the github repository and supplemental
  repository. The types are the most interesting part, however.
+ We decided to implement Okasaki's Braun algorithms because his papers
  are well-written and we started this project in a class; we generalized
  to CLRS, searching for algorithms that would challenge the framework.
